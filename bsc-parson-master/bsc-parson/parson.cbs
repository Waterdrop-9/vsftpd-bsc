#include "parson.hbs"

#define PARSON_IMPL_VERSION_MAJOR 1
#define PARSON_IMPL_VERSION_MINOR 5
#define PARSON_IMPL_VERSION_PATCH 3

#if (PARSON_VERSION_MAJOR != PARSON_IMPL_VERSION_MAJOR)\
|| (PARSON_VERSION_MINOR != PARSON_IMPL_VERSION_MINOR)\
|| (PARSON_VERSION_PATCH != PARSON_IMPL_VERSION_PATCH)
#error "parson version mismatch between parson.c and parson.h"
#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <errno.h>

#define STARTING_CAPACITY 16
#define MAX_NESTING       2048

#ifndef PARSON_INDENT_STR
#define PARSON_INDENT_STR "    "
#endif

#define SIZEOF_TOKEN(a)       (sizeof(a) - 1)
#define SKIP_CHAR(cur_index)        unsafe { cur_index++; }
#define SKIP_WHITESPACES(str, cur_index) unsafe { while (isspace((unsigned char)(*(str + cur_index)))) { SKIP_CHAR(cur_index) } }
#define MAX(a, b)             ((a) > (b) ? (a) : (b))


#if defined(isnan) && defined(isinf)
#define IS_NUMBER_INVALID(x) (isnan((x)) || isinf((x)))
#else
#define IS_NUMBER_INVALID(x) (((x) * 0.0) != 0.0)
#endif

#define OBJECT_INVALID_IX ((size_t)-1)

#define IS_CONT(b) (((unsigned char)(b) & 0xC0) == 0x80) /* is utf-8 continuation byte */

// typedef int parson_bool_t;

// #define PARSON_TRUE 1
// #define PARSON_FALSE 0

// used for traversing json string
size_t cur_index = 0;

unsafe void free_JSON_Object(JSON_Object* owned jo) {
    if (jo == NULL) {
        return;
    }
    JSON_Object tmp = *jo;
    safe_free((void* owned)jo);
    // AUTO INSERT: ~JSON_Object(tmp)
}

unsafe void free_JSON_Array(JSON_Array* owned ja) {
    if (ja == NULL) {
        return;
    }
    JSON_Array tmp = *ja;
    safe_free((void* owned)ja);
    // AUTO INSERT: ~JSON_Array(tmp)
}

/* Various */
unsafe static String read_file(const char* filename);

safe static int         hex_char_to_int(char c);
safe static JSON_Status parse_utf16_hex(const String* borrow string, unsigned int* borrow index, unsigned int* borrow result);
safe static _Bool is_decimal(const String* borrow string, size_t length);
safe static unsigned long hash_string(const String* borrow string);

/* JSON Object */
safe JSON_Object        JSON_Object::new (void);
safe void               JSON_Object::init(JSON_Object* borrow this, size_t capacity);
safe void               JSON_Object::grow_and_rehash(JSON_Object* borrow this);
safe size_t             JSON_Object::get_cell_ix(const JSON_Object* borrow this, const String* borrow key, unsigned long hash, _Bool* borrow out_found);
safe void               JSON_Object::add (JSON_Object* borrow this, String name, JSON_Value value);
safe JSON_Value* borrow JSON_Object::getn_value(JSON_Object* borrow this, const String* borrow name);
safe void               JSON_Object::remove_internal(JSON_Object* borrow this, const String* borrow name);

/* JSON Array */
safe JSON_Array  JSON_Array::new(void);
safe void        JSON_Array::add(JSON_Array* borrow this, JSON_Value value);
safe void        JSON_Array::resize(JSON_Array* borrow this);

/* JSON Value */
safe JSON_Value_Value JSON_Value_Value::new(void);
safe JSON_Value       JSON_Value::new(void);
safe void             JSON_Value::init_string_no_copy(JSON_Value* borrow this, String string);

/* Parser */
safe static JSON_Status skip_quotes      (const String* borrow string);
safe static JSON_Status parse_utf16      (const String* borrow unprocessed, unsigned int* borrow input_ptr, String* borrow processed);
safe static String      process_string   (const String* borrow string, size_t input_len);
safe static String      get_quoted_string(const String* borrow string);
safe void JSON_Value::parse_object_value (JSON_Value* borrow this, const String* borrow string, size_t nesting);
safe void JSON_Value::parse_array_value  (JSON_Value* borrow this, const String* borrow string, size_t nesting);
safe void JSON_Value::parse_string_value (JSON_Value* borrow this, const String* borrow string);
safe void JSON_Value::parse_boolean_value(JSON_Value* borrow this, const String* borrow string);
safe void JSON_Value::parse_number_value (JSON_Value* borrow this, const String* borrow string);
safe void JSON_Value::parse_null_value   (JSON_Value* borrow this, const String* borrow string);
safe void JSON_Value::parse_value        (JSON_Value* borrow this, const String* borrow string, size_t nesting);

/* Serialization */
safe static String json_serialize_string(const String* borrow string);

/*--------------------------------- Various ---------------------------------*/

// REWRITE NOTE:
// 1. use owned pointer to ensure releasing of the FILE resource
// 2. use String to replace char* type
unsafe static String read_file(const char* filename) {
    FILE* owned fp = (FILE* owned)fopen(filename, "r");
    size_t size_to_read = 0;
    size_t size_read = 0;
    long pos;
    // String file_contents;
    if (fp == NULL) {
        return String::new();
    }
    fseek((FILE *)&mut *fp, 0L, SEEK_END);
    pos = ftell((FILE *)&mut *fp);
    if (pos < 0) {
        fclose((FILE *)fp);
        return String::new();
    }
    size_to_read = pos;
    rewind((FILE *)&mut *fp);
    String file_contents = String::with_capacity(size_to_read + 1);
    if (!file_contents.capacity()) {
        fclose((FILE *)fp);
        // AUTO INSERT: ~String(file_contents)
        return String::new();
    }
    size_read = fread((char *)file_contents.as_mut_str(), 1, size_to_read, (FILE *)&mut *fp);
    if (size_read == 0 || ferror((FILE *)&mut *fp)) {
        fclose((FILE *)fp);
        // AUTO INSERT: ~String(file_contents)
        return String::new();
    }
    fclose((FILE *)fp);
    // Note: must update len manually!
    unsafe { file_contents.vec.len = size_read + 1; }
    file_contents.set(size_read, '\0');
    return file_contents;
}

safe static int hex_char_to_int(char c) {
    if (c >= '0' && c <= '9') {
        return c - '0';
    } else if (c >= 'a' && c <= 'f') {
        return c - 'a' + 10;
    } else if (c >= 'A' && c <= 'F') {
        return c - 'A' + 10;
    }
    return -1;
}

safe static JSON_Status parse_utf16_hex(const String* borrow s, unsigned int* borrow index, unsigned int* borrow result) {
    // int x1, x2, x3, x4;
    if (s->at(*index + 0) == '\0' || s->at(*index + 1) == '\0' ||
        s->at(*index + 2) == '\0' || s->at(*index + 3) == '\0') {
        return JSONFailure;
    }
    int x1 = hex_char_to_int(s->at(*index + 0));
    int x2 = hex_char_to_int(s->at(*index + 1));
    int x3 = hex_char_to_int(s->at(*index + 2));
    int x4 = hex_char_to_int(s->at(*index + 3));
    if (x1 == -1 || x2 == -1 || x3 == -1 || x4 == -1) {
        return JSONFailure;
    }
    unsafe {
        *result = (unsigned int)((x1 << 12) | (x2 << 8) | (x3 << 4) | x4);
    }
    return JSONSuccess;
}

safe static _Bool is_decimal(const String* borrow string, size_t length) {
    if (length > 1 && string->at(cur_index) == '0' && string->at(cur_index + 1) != '.') {
        return 0;
    }
    unsafe {
        if (length > 2 && !strncmp((const char*)string->as_str(), "-0", 2) && string->at(cur_index + 2) != '.') {
            return 0;
        }
    }
    while (length) {
        unsafe {
            if (strchr("xX", string->at(cur_index + length))) {
                return 0;
            }
        }
        length -= 1;
    }
    return 1;
}

safe static unsigned long hash_string(const String* borrow string) {
#ifdef PARSON_FORCE_HASH_COLLISIONS
    return 0;
#else
    unsigned char c = 0;
    unsigned long hash = 5381;
    size_t i = 0;
    for (i = 0; i < string->length(); i += 1) {
        unsafe { c = string->at(i); }
        if (c == '\0') {
            break;
        }
        unsafe {
            hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
        }
    }
    return hash;
#endif
}

/*-------------------------------- JSON Object --------------------------------*/

safe JSON_Object JSON_Object::new(void) {
    JSON_Object jo = {
        .cells         = Vec<size_t>::new(),
        .hashes        = Vec<unsigned long>::new(),
        .names         = Vec<String>::new(),
        .values        = Vec<JSON_Value>::new(),
        .cell_ixs      = Vec<size_t>::new(),
        .count         = 0,
        .item_capacity = 0,
        .cell_capacity = 0
    };
    jo.init(0);
    return jo;
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Object
safe void JSON_Object::init(JSON_Object* borrow this, size_t capacity) {
    this->count = 0;
    this->cell_capacity = capacity;
    unsafe { this->item_capacity = (unsigned int)(capacity * 7/10); }

    if (capacity == 0) {
        return;
    }

    Vec<size_t> cells = Vec<size_t>::with_capacity(this->cell_capacity);
    safe_swap(&mut this->cells, &mut cells);
    Vec<unsigned long> hashes = Vec<unsigned long>::with_capacity(this->item_capacity);
    Vec<String> names = Vec<String>::with_capacity(this->item_capacity);
    safe_swap(&mut this->names, &mut names);
    Vec<JSON_Value> values = Vec<JSON_Value>::with_capacity(this->item_capacity);
    safe_swap(&mut this->values, &mut values);
    Vec<size_t> cell_ixs = Vec<size_t>::with_capacity(this->item_capacity);
    safe_swap(&mut this->cell_ixs, &mut cell_ixs);

    for (size_t i = 0; i < this->cell_capacity; i += 1) {
        unsafe { this->cells.set(i, OBJECT_INVALID_IX); }
    }
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Object
safe void JSON_Object::grow_and_rehash(JSON_Object* borrow this) {
    JSON_Object new_object = JSON_Object::new();
    size_t new_capacity = MAX(this->cell_capacity * 2, STARTING_CAPACITY);
    new_object.init(new_capacity);

    for (size_t i = 0; i < this->count; i += 1) {
        String key = this->names.pop();
        JSON_Value value = this->values.pop();
        new_object.add(key, value);
    }

    safe_swap(this, &mut new_object);
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Object
safe size_t JSON_Object::get_cell_ix(const JSON_Object* borrow this, const String* borrow key, unsigned long hash, _Bool* borrow out_found) {
    size_t cell_ix = hash & (this->cell_capacity - 1);

    *out_found = 0;

    for (size_t i = 0; i < this->cell_capacity; i += 1) {
        size_t ix = (cell_ix + i) & (this->cell_capacity - 1);
        size_t cell = *this->cells.get(ix);
        unsafe {
            if (cell == OBJECT_INVALID_IX) {
                return ix;
            }
        }
        unsigned long hash_to_check = *this->hashes.get(cell);
        if (hash != hash_to_check) {
            continue;
        }
        const String* borrow key_to_check = this->names.get(cell);
        if (key_to_check->equals(key)) {
            *out_found = 1;
            return ix;
        }
    }
    unsafe {
        return OBJECT_INVALID_IX;
    }
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Object
safe void JSON_Object::add(JSON_Object* borrow this, String name, JSON_Value value) {
    _Bool found = 0;
    unsigned long hash = hash_string(&const name);
    size_t cell_ix = this->get_cell_ix(&const name, hash, &mut found);
    if (found) {
        // AUTO INSERT: ~String(name)
        // AUTO INSERT: ~JSON_Value(value)
        return;
    }

    if (this->count >= this->item_capacity) {
        this->grow_and_rehash();
        cell_ix = this->get_cell_ix(&const name, hash, &mut found);
    }

    this->cells.set(cell_ix, this->count);
    this->hashes.push(hash);
    this->names.push(name);
    this->values.push(value);
    this->cell_ixs.push(hash);
    this->count += 1;
}

safe JSON_Value* borrow JSON_Object::getn_value(JSON_Object* borrow this, const String* borrow name) {
    _Bool found = 0;
    unsigned long hash = hash_string(name);
    found = 0;
    size_t cell_ix = this->get_cell_ix(name, hash, &mut found);
    if (!found) {
        // TODO: how to deal with it?
        unsafe { return (JSON_Value* borrow)NULL; }
    }
    size_t item_ix = *this->cells.get(cell_ix);
    return this->values.get_mut(item_ix);
}

safe void JSON_Object::remove_internal(JSON_Object* borrow this, const String* borrow name) {
    unsigned long hash = hash_string(name);
    _Bool found = 0;
    size_t cell = this->get_cell_ix(name, hash, &mut found);
    if (!found) {
        return;
    }

    size_t item_ix = *this->cells.get(cell);
    size_t last_item_ix = this->count - 1;
    if (item_ix < last_item_ix) {
        unsafe {
            String *s1 = (String *)this->names.get_mut(item_ix);
            String tmp = *s1;
            String *s2 = (String *)this->names.get_mut(last_item_ix);
            *s1 = *s2;
            *s2 = tmp;
        }
        // safe_swap(this->names.get_mut(item_ix), this->names.get_mut(last_item_ix));
        String namep = this->names.pop();
        unsafe {
            String *s1 = (String *)this->names.get_mut(item_ix);
            String tmp = *s1;
            String *s2 = (String *)this->names.get_mut(last_item_ix);
            *s1 = *s2;
            *s2 = tmp;
        }
        // safe_swap(this->values.get_mut(item_ix), this->values.get_mut(last_item_ix));
        JSON_Value valuep = this->values.pop();
        size_t idx = *this->cell_ixs.get(last_item_ix);
        this->cell_ixs.set(item_ix, idx);
        size_t cell_ixp = this->cell_ixs.pop();
        size_t hash = *this->hashes.get(last_item_ix);
        this->hashes.set(item_ix, hash);
        unsigned long hashp = this->hashes.pop();
        size_t pos = *this->cell_ixs.get(item_ix);
        this->cells.set(pos, item_ix);
    } else {
        String namep = this->names.pop();
        JSON_Value valuep = this->values.pop();
        size_t cell_ixp = this->cell_ixs.pop();
        unsigned long hashp = this->hashes.pop();
    }
    this->count -= 1;

    size_t i = cell;
    size_t j = i;
    for (size_t x = 0; x < (this->cell_capacity - 1); x += 1) {
        j = (j + 1) & (this->cell_capacity - 1);
        unsafe {
            if (*this->cells.get(j) == OBJECT_INVALID_IX) {
                break;
            }
        }
        size_t k = *this->hashes.get(*this->cells.get(j)) & (this->cell_capacity - 1);
        if ((j > i && (k <= i || k > j))
         || (j < i && (k <= i && k > j))) {
            size_t cell1 = *this->cells.get(j);
            this->cell_ixs.set(cell1, i);
            size_t cell2 = *this->cells.get(j);
            this->cells.set(i, cell2);
            i = j;
        }
    }
    unsafe { this->cells.set(i, OBJECT_INVALID_IX); }
}


/*-------------------------------- JSON Array --------------------------------*/

safe JSON_Array JSON_Array::new(void) {
    Vec<JSON_Value> vec = Vec<JSON_Value>::new();
    JSON_Array ja = { .items = vec };
    return ja;
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Array
// 2. call `Vec::push` instead of manually memory management
safe void JSON_Array::add(JSON_Array* borrow this, JSON_Value value) {
    this->items.push(value);
}

// REWRITE NOTE:
// 1. make it a member function of JSON_Array
// 2. call `Vec::shrink_to_fit` instead of manually memory management
safe void JSON_Array::resize(JSON_Array* borrow this) {
    this->items.shrink_to_fit();
}


/*------------------------------- JSON Value --------------------------------*/

safe JSON_Value_Value JSON_Value_Value::new(void) {
    String s = String::new();
    JSON_Object jo = JSON_Object::new();
    JSON_Array ja = JSON_Array::new();
    JSON_Value_Value jvv = {
        .string  = s,
        .number  = 0,
        .object  = safe_malloc(jo),
        .array   = safe_malloc(ja),
        .boolean = -1,
        .null    = 0
    };
    return jvv;
}

safe JSON_Value JSON_Value::new(void) {
    JSON_Value_Value jvv = JSON_Value_Value::new();
    JSON_Value jv = { .type = JSONError, .value = jvv };
    return jv;
}

safe void JSON_Value::init_string_no_copy(JSON_Value* borrow this, String string) {
    this->type = JSONString;
    safe_swap(&mut this->value.string, &mut string);
    // AUTO INSERT: ~String(string)
}

/*---------------------------------- Parser ----------------------------------*/

safe static JSON_Status skip_quotes(const String* borrow string) {
    if (string->at(cur_index) != '\"') {
        return JSONFailure;
    }
    SKIP_CHAR(cur_index)
    while (string->at(cur_index) != '\"') {
        if (string->at(cur_index) == '\0') {
            return JSONFailure;
        } else if (string->at(cur_index) == '\\') {
            SKIP_CHAR(cur_index)
            if (string->at(cur_index) == '\0') {
                return JSONFailure;
            }
        }
        SKIP_CHAR(cur_index)
    }
    SKIP_CHAR(cur_index)
    return JSONSuccess;
}

safe static JSON_Status parse_utf16(const String* borrow unprocessed, unsigned int* borrow input_ptr, String* borrow processed) {
    unsigned int cp = 0, lead = 0, trail = 0;
    JSON_Status status = JSONFailure;
    *input_ptr += 1; /* skips u */
    status = parse_utf16_hex(unprocessed, input_ptr, &mut cp);
    if (status != JSONSuccess) {
        return JSONFailure;
    }
    if (cp < 0x80) {
        unsafe {
            processed->push((char)cp); /* 0xxxxxxx */
        }
    } else if (cp < 0x800) {
        unsafe {
            processed->push(((cp >> 6) & 0x1F) | 0xC0); /* 110xxxxx */
            processed->push(((cp)      & 0x3F) | 0x80); /* 10xxxxxx */
        }
    } else if (cp < 0xD800 || cp > 0xDFFF) {
        unsafe {
            processed->push(((cp >> 12) & 0x0F) | 0xE0); /* 1110xxxx */
            processed->push(((cp >> 6)  & 0x3F) | 0x80); /* 10xxxxxx */
            processed->push(((cp)       & 0x3F) | 0x80); /* 10xxxxxx */
        }
    } else if (cp >= 0xD800 && cp <= 0xDBFF) { /* lead surrogate (0xD800..0xDBFF) */
        lead = cp;
        *input_ptr += 4; /* should always be within the buffer, otherwise previous sscanf would fail */
        if (unprocessed->at(*input_ptr) != '\\' || unprocessed->at(*input_ptr + 1) != 'u') {
            return JSONFailure;
        }
        *input_ptr += 2;
        status = parse_utf16_hex(unprocessed, input_ptr, &mut trail);
        if (status != JSONSuccess || trail < 0xDC00 || trail > 0xDFFF) { /* valid trail surrogate? (0xDC00..0xDFFF) */
            return JSONFailure;
        }
        cp = ((((lead - 0xD800) & 0x3FF) << 10) | ((trail - 0xDC00) & 0x3FF)) + 0x010000;
        unsafe {
            processed->push((((cp >> 18) & 0x07) | 0xF0)); /* 11110xxx */
            processed->push((((cp >> 12) & 0x3F) | 0x80)); /* 10xxxxxx */
            processed->push((((cp >> 6)  & 0x3F) | 0x80)); /* 10xxxxxx */
            processed->push((((cp)       & 0x3F) | 0x80)); /* 10xxxxxx */
        }
    } else { /* trail surrogate before lead surrogate */
        return JSONFailure;
    }
    *input_ptr += 3;
    return JSONSuccess;
}

safe static String process_string(const String* borrow string, size_t input_len) {
    size_t input_ptr = cur_index - input_len - 2;
    size_t initial_size = (input_len + 1) * sizeof(char);
    String output = String::with_capacity(initial_size);
    while ((string->at(input_ptr) != '\0') && input_ptr < cur_index) {
        if (string->at(input_ptr) == '\\') {
            input_ptr += 1;
            switch (string->at(input_ptr)) {
                case '\"': output.push('\"'); break;
                case '\\': output.push('\\'); break;
                case '/':  output.push('/');  break;
                case 'b':  output.push('\b'); break;
                case 'f':  output.push('\f'); break;
                case 'n':  output.push('\n'); break;
                case 'r':  output.push('\r'); break;
                case 't':  output.push('\t'); break;
                case 'u':
                    unsafe {
                        unsigned int cast_input_ptr = input_ptr;
                        if (parse_utf16(string, &mut cast_input_ptr, &mut output) != JSONSuccess) {
                            return String::new();
                        }
                        input_ptr = cast_input_ptr;
                    }
                    break;
                default:
                    return String::new();
            }
        } else {
            unsafe {
                if ((unsigned char)string->at(input_ptr) < 0x20) {
                    return String::new(); /* 0x00-0x19 are invalid characters for json string (http://www.ietf.org/rfc/rfc4627.txt) */
                } else {
                    output.push(string->at(input_ptr));
                }
            }
        }
        input_ptr += 1;
    }
    output.push('\0');
    /* resize to new length */
    output.shrink_to_fit();
    return output;
}

safe static String get_quoted_string(const String* borrow string) {
    size_t string_start = cur_index;
    size_t input_string_len = 0;
    JSON_Status status = skip_quotes(string);
    if (status != JSONSuccess) {
        return String::new();
    }
    input_string_len = cur_index - string_start - 2; /* length without quotes */
    return process_string(string, input_string_len);
}

// REWRITE NOTE:
// 1. replace `const char **` with `const String* borrow`
// 2. make it a member function of JSON_Value
// 3. replace manually call `free` with destructor
safe void JSON_Value::parse_object_value(JSON_Value* borrow this, const String* borrow string, size_t nesting) {
    this->init_object();
    JSON_Value new_value = JSON_Value::new();
    if (string->at(cur_index) != '{') {
        this->init();
        // AUTO INSERT: ~JSON_Value(new_value)
        return;
    }
    JSON_Object* borrow output_object = this->get_object();
    SKIP_CHAR(cur_index)
    SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
    if (string->at(cur_index) == '}') { /* empty object */
        SKIP_CHAR(cur_index)
        // AUTO INSERT: ~JSON_Value(new_value)
        return;
    }
    while (string->at(cur_index) != '\0') {
        String new_key = get_quoted_string(string);
        /* We do not support key names with embedded \0 chars */
        if (new_key.length() < 2) {
            this->init();
            // AUTO_INSERT: ~String(new_key)
            // AUTO INSERT: ~JSON_Value(new_value)
            return;
        }
        SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
        if (string->at(cur_index) != ':') {
            this->init();
            // AUTO_INSERT: ~String(new_key)
            // AUTO INSERT: ~JSON_Value(new_value)
            return;
        }
        SKIP_CHAR(cur_index)
        new_value.parse_value(string, nesting);
        if (new_value.get_type() == JSONError) {
            this->init();
            // AUTO_INSERT: ~String(new_key)
            // AUTO INSERT: ~JSON_Value(new_value)
            return;
        }
        output_object->add(new_key, new_value);
        new_key = String::new();
        new_value = JSON_Value::new();
        SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
        if (string->at(cur_index) != ',') {
            break;
        }
        SKIP_CHAR(cur_index)
        SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
        if (string->at(cur_index) == '}') {
            break;
        }
    }
    SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
    if (string->at(cur_index) != '}') {
        // FIXME: unfriendly coding pattern
        JSON_Value* borrow _this = this;
        _this->init();
        // AUTO_INSERT: ~String(new_key)
        // AUTO INSERT: ~JSON_Value(new_value)
        return;
    }
    SKIP_CHAR(cur_index)
    // AUTO_INSERT: ~String(new_key)
    // AUTO INSERT: ~JSON_Value(new_value)
    return;
}

// REWRITE NOTE:
// 1. replace `const char **` with `const String* borrow`
// 2. make it a member function of JSON_Value
// 3. replace manually call `free` with destructor
safe void JSON_Value::parse_array_value(JSON_Value* borrow this, const String* borrow string, size_t nesting) {
    this->init_array();
    JSON_Value new_array_value = JSON_Value::new();
    if (string->at(cur_index) != '[') {
        this->init();
        // AUTO INSERT: ~JSON_Value(new_array_value)
        return;
    }
    JSON_Array* borrow output_array = this->get_array();
    SKIP_CHAR(cur_index)
    SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
    if (string->at(cur_index) == ']') { /* empty array */
        SKIP_CHAR(cur_index)
        // AUTO INSERT: ~JSON_Value(new_array_value)
        return;
    }
    while (string->at(cur_index) != '\0') {
        new_array_value.parse_value(string, nesting);
        if (new_array_value.get_type() == JSONError) {
            this->init();
            // AUTO INSERT: ~JSON_Value(new_array_value)
            return;
        }
        output_array->add(new_array_value);
        new_array_value = JSON_Value::new();
        SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
        if (string->at(cur_index) != ',') {
            break;
        }
        SKIP_CHAR(cur_index)
        SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
        if (string->at(cur_index) == ']') {
            break;
        }
    }
    SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
    if (string->at(cur_index) == ']') {
        output_array->resize();
    } else {
        // FIXME： unfriendly coding pattern
        JSON_Value* borrow _this = this;
        _this->init();
        return;
    }
    SKIP_CHAR(cur_index)
    return;
}

safe void JSON_Value::parse_string_value(JSON_Value* borrow this, const String* borrow string) {
    String new_string = get_quoted_string(string);
    if (new_string.is_empty()) {
        this->init();
        return;
    }
    this->init_string_no_copy(new_string);
    return;
}

// REWRITE NOTE:
// 1. replace `const char **` with `const String* borrow`
// 2. make it a member function of JSON_Value
safe void JSON_Value::parse_boolean_value(JSON_Value* borrow this, const String* borrow string) {
    size_t true_token_size = SIZEOF_TOKEN("true");
    size_t false_token_size = SIZEOF_TOKEN("false");
    unsafe {
        if (strncmp("true", (const char*)string->as_str() + cur_index, true_token_size) == 0) {
            cur_index += true_token_size;
            this->init_boolean(1);
        } else if (strncmp("false", (const char*)string->as_str() + cur_index, false_token_size) == 0) {
            cur_index += false_token_size;
            this->init_boolean(0);
        }
    }
}

safe void JSON_Value::parse_number_value(JSON_Value* borrow this, const String* borrow string) {
    double number = 0;
    unsafe {
        errno = 0;
        char *end;
        number = strtod((const char*)string->get(cur_index), &end);
        if (errno == ERANGE && (number <= -HUGE_VAL || number >= HUGE_VAL)) {
            this->init();
            return;
        }
        size_t length = end - (const char*)string->get(cur_index);
        if ((errno && errno != ERANGE) || !is_decimal(string, length)) {
            this->init();
            return;
        }
        cur_index += length;
    }
    return this->init_number(number);
}

// REWRITE NOTE:
// 1. replace `const char **` with `const String* borrow`
// 2. make it a member function of JSON_Value
safe void JSON_Value::parse_null_value(JSON_Value* borrow this, const String* borrow string) {
    size_t token_size = SIZEOF_TOKEN("null");
    unsafe {
        if (strncmp("null", (const char*)string->get(cur_index), token_size) == 0) {
            cur_index += token_size;
            this->init_null();
            return;
        }
    }
    this->init();
}

// REWRITE NOTE:
// 1. replace `const char **` with `const String* borrow`
// 2. make it a member function of JSON_Value
safe void JSON_Value::parse_value(JSON_Value* borrow this, const String* borrow string, size_t nesting) {
    if (nesting > MAX_NESTING) {
        return;
    }
    SKIP_WHITESPACES((const char*)string->as_str(), cur_index)
    switch (string->at(cur_index)) {
        case '{':
            this->parse_object_value(string, nesting + 1);
            break;
        case '[':
            this->parse_array_value(string, nesting + 1);
            break;
        case '\"':
            this->parse_string_value(string);
            break;
        case 'f': case 't':
            this->parse_boolean_value(string);
            break;
        case '-':
        case '0': case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8': case '9':
            this->parse_number_value(string);
            break;
        case 'n':
            this->parse_null_value(string);
            break;
        default:
            return;
    }
}

safe static String json_serialize_string(const String* borrow string) {
    String s = String::new();
    int written = -1, written_total = 0;
    for (size_t i = 0; i < string->length(); i += 1) {
        char c = string->at(i);
        switch (c) {
            case '\"': s.push('\\'); s.push('\"'); break;
            case '\\': s.push('\\'); s.push('\\'); break;
            case '\b': s.push('\\'); s.push('b'); break;
            case '\f': s.push('\\'); s.push('f'); break;
            case '\n': s.push('\\'); s.push('n'); break;
            case '\r': s.push('\\'); s.push('r'); break;
            case '\t': s.push('\\'); s.push('t'); break;
            case '\x00': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('0'); break;
            case '\x01': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('1'); break;
            case '\x02': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('2'); break;
            case '\x03': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('3'); break;
            case '\x04': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('4'); break;
            case '\x05': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('5'); break;
            case '\x06': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('6'); break;
            case '\x07': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('7'); break;
            /* '\x08' duplicate: '\b' */
            /* '\x09' duplicate: '\t' */
            /* '\x0a' duplicate: '\n' */
            case '\x0b': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('b'); break;
            /* '\x0c' duplicate: '\f' */
            /* '\x0d' duplicate: '\r' */
            case '\x0e': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('e'); break;
            case '\x0f': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('0'); s.push('f'); break;
            case '\x10': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('0'); break;
            case '\x11': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('1'); break;
            case '\x12': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('2'); break;
            case '\x13': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('3'); break;
            case '\x14': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('4'); break;
            case '\x15': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('5'); break;
            case '\x16': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('6'); break;
            case '\x17': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('7'); break;
            case '\x18': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('8'); break;
            case '\x19': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('9'); break;
            case '\x1a': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('a'); break;
            case '\x1b': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('b'); break;
            case '\x1c': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('c'); break;
            case '\x1d': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('d'); break;
            case '\x1e': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('e'); break;
            case '\x1f': s.push('\\'); s.push('u'); s.push('0'); s.push('0'); s.push('1'); s.push('f'); break;
            case '/': s.push('/'); break;
            default:
                break;
        }
    }
    s.push('\0');
    return s;
}

/*----------------------------- JSON Parser API -----------------------------*/

/* entry point for parsing json file */
// REWRITE NOTE:
// 1. use String to replace char* type
// 2. use JSON_Value to replace JSON_Value* type
safe JSON_Value json_parse_file(String filename) {
    String file_contents = String::new();
    unsafe {
        String tmp = read_file((const char *)filename.as_str());
        safe_swap(&mut file_contents, &mut tmp);
    }
    JSON_Value output_value = JSON_Value::new();
    if (file_contents.is_empty()) {
        // AUTO INSERT: ~String(file_contents)
        return output_value;
    }
    output_value.json_parse_string(&const file_contents);
    // AUTO INSERT: ~String(file_contents)
    return output_value;
}

// REWRITE NOTE：
// 1. replace `const char *` with `const String* borrow`
// 2. make it a member function of JSON_Value
safe void JSON_Value::json_parse_string(JSON_Value* borrow this, const String* borrow string) {
    if (string->is_empty()) {
        return;
    }
    cur_index = 0;
    if (string->at(0) == '\xEF' && string->at(1) == '\xBB' && string->at(2) == '\xBF') {
        cur_index += 3; /* Support for UTF-8 BOM */
    }
    this->parse_value(string, 0);
}

safe _Bool JSON_Value::equals(JSON_Value* borrow this, JSON_Value* borrow other) {
    JSON_Value_Type this_type = this->get_type();
    JSON_Value_Type other_type = other->get_type();
    if (this_type != other_type) {
        return 0;
    }
    switch (this_type) {
        case JSONArray: {
            JSON_Array* borrow this_array = this->get_array();
            JSON_Array* borrow other_array = other->get_array();
            size_t this_count = this_array->get_count();
            size_t other_count = other_array->get_count();
            if (this_count != other_count) {
                return 0;
            }
            for (size_t i = 0; i < this_count; i += 1) {
                if (!this_array->get_value(i)->equals(other_array->get_value(i))) {
                    return 0;
                }
            }
            return 1;
        }
        case JSONObject: {
            JSON_Object* borrow this_object = this->get_object();
            JSON_Object* borrow other_object = other->get_object();
            size_t this_count = this_object->get_count();
            size_t other_count = other_object->get_count();
            if (this_count != other_count) {
                return 0;
            }
            for (size_t i = 0; i < this_count; i += 1) {
                const String* borrow key = this_object->get_name(i);
                unsafe {
                    String key1 = String::from((const char *)key->as_str());
                    if (!this_object->get_value(&const key1)->equals(other_object->get_value(&const key1))) {
                        return 0;
                    }
                }
            }
            return 1;
        }
        case JSONString: {
            String* borrow this_string = this->get_string();
            String* borrow other_string = other->get_string();
            return this_string->equals(&const *other_string);
        }
        case JSONBoolean:
            unsafe { return this->get_boolean() == other->get_boolean(); }
        case JSONNumber:
            unsafe { return fabs(this->get_number() - other->get_number()) < 0.000001; } /* EPSILON */
        case JSONError:
            return 1;
        case JSONNull:
            return 1;
        default:
            return 1;
    }
}

safe _Bool JSON_Value::validate(JSON_Value* borrow this, JSON_Value* borrow schema) {
    JSON_Value_Type schema_type = schema->get_type();
    JSON_Value_Type this_type = this->get_type();
    if (schema_type != this_type && schema_type != JSONNull) { /* null represents all values */
        return 0;
    }
    switch (schema_type) {
        case JSONArray: {
            JSON_Array* borrow schema_array = schema->get_array();
            JSON_Array* borrow this_array = this->get_array();
            size_t this_count = this_array->get_count();
            size_t count = schema_array->get_count();
            if (count == 0) {
                return 1; /* Empty array allows all types */
            }
            /* Get first value from array, rest is ignored */
            JSON_Value* borrow temp_schema_value = schema_array->get_value(0);
            for (size_t i = 0; i < this_count; i += 1) {
                JSON_Value* borrow temp_value = this_array->get_value(i);
                if (!temp_value->validate(temp_schema_value)) {
                    return 0;
                }
            }
            return 1;
        }
        case JSONObject: {
            JSON_Object* borrow schema_object = schema->get_object();
            JSON_Object* borrow this_object = this->get_object();
            size_t this_count = this_object->get_count();
            size_t count = schema_object->get_count();
            if (count == 0) {
                return 1; /* Empty object allows all objects */
            } else if (this_count < count) {
                return 0; /* Tested object mustn't have less name-value pairs than schema */
            }
            for (size_t i = 0; i < count; i += 1) {
                unsafe {
                    String key1 = String::from((const char *)schema_object->get_name(i)->as_str());
                    String key2 = String::from((const char *)schema_object->get_name(i)->as_str());
                    JSON_Value* borrow temp_schema_value = schema_object->get_value(&const key1);
                    JSON_Value* borrow temp_value = this_object->get_value(&const key2);
                    if (!temp_value->validate(temp_schema_value)) {
                        return 0;
                    }
                }
            }
            return 1;
        }
        case JSONString: case JSONNumber: case JSONBoolean: case JSONNull:
            return 1; /* equality already tested before switch */
        case JSONError: default:
            return 0;
    }
}


/*------------------------------JSON Object API------------------------------*/

// RAFACTOR
// 1. make it a member function of JSON_Object
safe JSON_Value* borrow JSON_Object::get_value(JSON_Object* borrow this, const String* borrow name) {
    return this->getn_value(name);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe String* borrow JSON_Object::get_string(JSON_Object* borrow this, const String* borrow name) {
    JSON_Value* borrow value = this->get_value(name);
    return value->get_string();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe JSON_Object* borrow JSON_Object::get_object(JSON_Object* borrow this, const String* borrow name) {
    return this->get_value(name)->get_object();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe JSON_Array* borrow JSON_Object::get_array(JSON_Object* borrow this, const String* borrow name) {
    return this->get_value(name)->get_array();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe double JSON_Object::get_number(JSON_Object* borrow this, const String* borrow name) {
    return this->get_value(name)->get_number();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe int JSON_Object::get_boolean(JSON_Object* borrow this, const String* borrow name) {
    return this->get_value(name)->get_boolean();
}


// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe JSON_Value* JSON_Object::dotget_value(JSON_Object* borrow this, const String* name) {
    size_t dot_position = name->find('.');
    if (dot_position == bsc_string_no_pos) {
        return (JSON_Value *)this->get_value(&const *name);
    }
    String slice1 = name->slice(0, dot_position);
    String slice2 = name->slice(0, dot_position);
    JSON_Object* object = (JSON_Object *)this->getn_value(&const slice1)->get_object();
    JSON_Value* value = object->dotget_value(&slice2);
    // AUTO INSERT: ~String(slice2)
    // AUTO INSERT: ~String(slice1)
    // AUTO INSERT: ~String(name)
    return value;
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe String* JSON_Object::dotget_string(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return (String *)value->get_string();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe JSON_Object* JSON_Object::dotget_object(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return (JSON_Object *)value->get_object();
    // return json_value_get_object(json_object_dotget_value(object, name));
}

// RAFACTOR
// 1. make it a member function of JSON_Object
JSON_Array * json_object_dotget_array(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return (JSON_Array *)value->get_array();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe double JSON_Object::dotget_number(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return value->get_number();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe int JSON_Object::dotget_boolean(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return value->get_boolean();
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe size_t JSON_Object::get_count(const JSON_Object* borrow this) {
    return this->count;
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe const String* borrow JSON_Object::get_name(const JSON_Object* borrow this, size_t index) {
    return this->names.get(index);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe JSON_Value* borrow JSON_Object::get_value_at(JSON_Object* borrow this, size_t index) {
    return this->values.get_mut(index);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe _Bool JSON_Object::has_value(const JSON_Object* borrow this, const String* borrow name) {
    _Bool found = 0;
    unsigned long hash = hash_string(name);
    size_t cell_ix = this->get_cell_ix(name, hash, &mut found);
    return found;
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe _Bool JSON_Object::has_value_of_type(JSON_Object* borrow this, const String* borrow name, JSON_Value_Type type) {
    _Bool found = 0;
    unsigned long hash = hash_string(name);
    size_t cell_ix = this->get_cell_ix(name, hash, &mut found);
    if (!found) {
        return found;
    }
    JSON_Value* borrow val = this->get_value(name);
    unsafe {
        return val->get_type() == type;
    }
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe _Bool JSON_Object::dothas_value(JSON_Object* borrow this, const String* name) {
    JSON_Value* value = this->dotget_value(name);
    return value != NULL;
}

// RAFACTOR
// 1. make it a member function of JSON_Object
unsafe _Bool JSON_Object::dothas_value_of_type(JSON_Object* borrow this, const String* name, JSON_Value_Type type) {
    JSON_Value* val = this->dotget_value(name);
    return val != NULL && val->get_type() == type;
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::set_value(JSON_Object* borrow this, String name, JSON_Value value) {
    unsigned long hash = hash_string(&const name);
    _Bool found = 0;
    size_t cell_ix = this->get_cell_ix(&const name, hash, &mut found);
    if (found) {
        size_t item_ix = *this->cells.get(cell_ix);
        JSON_Value* borrow old_value = this->values.get_mut(item_ix);
        safe_swap(old_value, &mut value);
        // AUTO INSERT: ~String(name)
        // AUTO INSERT: ~JSON_Value(value)
        return;
    }
    this->add(name, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::set_string(JSON_Object* borrow this, String name, String string) {
    JSON_Value value = JSON_Value::new();
    value.init_string(string);
    this->set_value(name, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::set_number(JSON_Object* borrow this, String name, double number) {
    JSON_Value value = JSON_Value::new();
    value.init_number(number);
    this->set_value(name, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::set_boolean(JSON_Object* borrow this, String name, int boolean) {
    JSON_Value value = JSON_Value::new();
    value.init_boolean(boolean);
    this->set_value(name, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::set_null(JSON_Object* borrow this, String name) {
    JSON_Value value = JSON_Value::new();
    value.init_null();
    this->set_value(name, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::remove(JSON_Object* borrow this, const String* borrow name) {
    return this->remove_internal(name);
}

// RAFACTOR
// 1. make it a member function of JSON_Object
safe void JSON_Object::clear(JSON_Object* borrow this) {
    this->hashes.clear();
    this->names.clear();
    this->values.clear();
    this->cell_ixs.clear();
    this->count = 0;
    for (size_t i = 0; i < this->cell_capacity; i += 1) {
        unsafe { this->cells.set(i, OBJECT_INVALID_IX); }
    }
}


/*-------------------------------JSON Array API-------------------------------*/

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Value* borrow JSON_Array::get_value(JSON_Array* borrow this, size_t index) {
    return this->items.get_mut(index);
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe String* borrow JSON_Array::get_string (JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_string();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe size_t JSON_Array::get_string_len(JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_string_len();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe double JSON_Array::get_number(JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_number();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Object* borrow JSON_Array::get_object(JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_object();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Array* borrow JSON_Array::get_array(JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_array();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe int JSON_Array::get_boolean(JSON_Array* borrow this, size_t index) {
    return this->get_value(index)->get_boolean();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe size_t JSON_Array::get_count(const JSON_Array* borrow this) {
    return this->items.length();
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::remove(JSON_Array* borrow this, size_t ix) {
    size_t to_move_bytes = 0;
    if (ix >= this->get_count()) {
        return JSONFailure;
    }
    JSON_Value removed = this->items.remove(ix);
    // ~JSON_Value(removed);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::replace_value(JSON_Array* borrow this, size_t ix, JSON_Value value) {
    if (ix >= this->get_count()) {
        return JSONFailure;
    }
    this->items.set(ix, value);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::replace_string(JSON_Array* borrow this, size_t i, String string) {
    JSON_Value value = JSON_Value::new();
    value.init_string(string);
    return this->replace_value(i, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::replace_number(JSON_Array* borrow this, size_t i, double number) {
    JSON_Value value = JSON_Value::new();
    value.init_number(number);
    if (value.get_type() == JSONError) {
        return JSONFailure;
    }
    return this->replace_value(i, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::replace_boolean(JSON_Array* borrow this, size_t i, int boolean) {
    JSON_Value value = JSON_Value::new();
    value.init_boolean(boolean);
    return this->replace_value(i, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::replace_null(JSON_Array* borrow this, size_t i) {
    JSON_Value value = JSON_Value::new();
    value.init_null();
    return this->replace_value(i, value);
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::clear(JSON_Array* borrow this) {
    this->items.clear();
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::append_value(JSON_Array* borrow this, JSON_Value value) {
    this->add(value);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::append_string(JSON_Array* borrow this, String string) {
    JSON_Value value = JSON_Value::new();
    value.init_string(string);
    this->add(value);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::append_number(JSON_Array* borrow this, double number) {
    JSON_Value value = JSON_Value::new();
    value.init_number(number);
    this->add(value);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::append_boolean(JSON_Array* borrow this, int boolean) {
    JSON_Value value = JSON_Value::new();
    value.init_boolean(boolean);
    this->add(value);
    return JSONSuccess;
}

// RAFACTOR
// 1. make it a member function of JSON_Array
safe JSON_Status JSON_Array::append_null(JSON_Array* borrow this) {
    JSON_Value value = JSON_Value::new();
    value.init_null();
    this->add(value);
    return JSONSuccess;
}

/*-------------------------------JSON Value API-------------------------------*/

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init(JSON_Value* borrow this) {
    this->type = JSONError;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_object(JSON_Value* borrow this) {
    this->type = JSONObject;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_array(JSON_Value* borrow this) {
    this->type = JSONArray;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_string(JSON_Value* borrow this, String string) {
    this->type = JSONString;
    safe_swap(&mut this->value.string, &mut string);
    // AUTO INSERT: ~String(string)
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_number(JSON_Value* borrow this, double number) {
    if (IS_NUMBER_INVALID(number)) {
        this->init();
        return;
    }
    this->type = JSONNumber;
    this->value.number = number;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_boolean(JSON_Value* borrow this, int boolean) {
    this->type = JSONBoolean;
    this->value.boolean = boolean ? 1 : 0;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe void JSON_Value::init_null(JSON_Value* borrow this) {
    this->type = JSONNull;
}


// RAFACTOR
// 1. make it a member function of JSON_Value
safe JSON_Value_Type JSON_Value::get_type(const JSON_Value* borrow this) {
    return this->type;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe JSON_Object* borrow JSON_Value::get_object(JSON_Value* borrow this) {
    return &mut *this->value.object;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe JSON_Array* borrow JSON_Value::get_array(JSON_Value* borrow this) {
    return &mut *this->value.array;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe String* borrow JSON_Value::get_string (JSON_Value* borrow this) {
    return &mut this->value.string;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe size_t JSON_Value::get_string_len(const JSON_Value* borrow this) {
    return this->value.string.length();
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe double JSON_Value::get_number(const JSON_Value* borrow this) {
    return this->value.number;
}

// RAFACTOR
// 1. make it a member function of JSON_Value
safe int JSON_Value::get_boolean(const JSON_Value* borrow this) {
    return this->value.boolean;
}


/*--------------------------- JSON Serialization ----------------------------*/
safe void json_dump(JSON_Value* borrow value) {
    switch (value->get_type()) {
        case JSONString: {
            unsafe { printf("%s", (char *)value->get_string()->as_mut_str()); }
            break;
        }
        case JSONNumber: {
            unsafe { printf("%lf", value->get_number()); }
            break;
        }
        case JSONObject: {
            unsafe { printf("{"); }
            JSON_Object* borrow object = value->get_object();
            size_t count = object->get_count();
            for (size_t index = 0; index < count; index += 1) {
                const String* borrow name = object->get_name(index);
                unsafe { printf("%s", (const char*)name->as_str()); }
                unsafe { printf(" : "); }
                JSON_Value* borrow value = object->get_value_at(index);
                json_dump(value);
                if (index != count - 1) {
                    unsafe { printf(", "); }
                }
            }
            unsafe { printf("}"); }
            break;
        }
        case JSONArray: {
            unsafe { printf("["); }
            JSON_Array* borrow array = value->get_array();
            size_t count = array->get_count();
            for (size_t index = 0; index < count; index += 1) {
                JSON_Value* borrow elem = array->get_value(index);
                json_dump(elem);
                if (index != count - 1) {
                    unsafe { printf(", "); }
                }
            }
            unsafe { printf("]\n"); }
            break;
        }
        case JSONBoolean: {
            int boolean = value->get_boolean();
            if (boolean) {
                unsafe { printf("true"); }
            } else {
                unsafe { printf("false"); }
            }
            break;
        }
        case JSONNull: {
            unsafe { printf("null"); }
            break;
        }
        default:
            unsafe { printf("Error!\n"); }
            return;
    }
}
