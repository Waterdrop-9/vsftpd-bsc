## 内存安全

毕昇 C 内存管理的目标是将常见的时间类内存安全问题，如悬挂引用/内存泄漏/重复释放堆内存/解引用空指针等常见的内存安全问题在编译阶段暴露出来。

为此，毕昇 C 引入了[所有权](https://gitee.com/bisheng_c_language_dep/llvm-project/blob/bishengc/15.0.4/clang/docs/BSC/BiShengCLanguageUserManual.md###所有权)和[借用](https://gitee.com/bisheng_c_language_dep/llvm-project/blob/bishengc/15.0.4/clang/docs/BSC/BiShengCLanguageUserManual.md###借用)两个新的概念，所有权用关键字`owned`实现，借用通过关键字`borrow`表示，并通过`safe`和`unsafe`两个关键字来约束所有权和借用的执行范围。

### 安全区

#### 概述：

c 语言有很多规则过于灵活，不方便编译器做静态检查。因此我们引入一个新语法，使得在一定范围内的毕昇 c 代码必须遵循更严格的约束，保证在这个范围内的代码肯定不会出现“内存安全”问题。

允许用`safe`和`unsafe`关键字修饰函数、语句、括号表达式。

- `unsafe`表示这段代码在非安全区，这部分代码遵循标准 c 的规定，同时这部分代码的安全性由用户保证。
- `safe`表示这段代码在安全区，这部分代码必须遵循更严格的约束，同时编译器可以保证内存安全。
- 没有 `safe`或`unsafe`关键字修饰的全局函数默认是非安全的。

#### 代码示例：

```
#include <stdlib.h>

typedef struct File {
} FileID;

// 无关键字修饰，表示按默认非安全区
FileID *owned create(void) {
  FileID *p = malloc(sizeof(FileID));
  return (FileID * owned) p;
}
FileID *owned consume_and_return(FileID *owned p) { return p; }

// 使用 safe 修饰函数，表示该函数为安全函数，函数内为安全区
safe void file_safe_free(FileID *owned p) {
  // 使用 unsafe 修饰代码块，表示这段代码在非安全区。这段代码是在安全区内的非安全区，也属于非安全区
  unsafe { free((FileID *)p); }
}

int main(void) {
  FileID *owned p1 = create();
  FileID *owned p2 = consume_and_return(p1);
  // 使用 safe 修饰语句，表示这段代码在安全区
  safe file_safe_free(p2);
  return 0;
}
```

#### 语法规则：

1. 允许使用`safe/unsafe`修饰函数声明、函数签名、函数定义、函数指针、语句、括号表达式。

```
// 修饰函数签名
safe int test(int, int);
// 修饰函数声明
safe int test(int a, int b);
// 修饰函数定义
safe int test(int a, int b) { return a + b; }
// 修饰函数指针
safe int (*p)(int, int);

safe int main(void) {
  // 修饰代码块
  safe {
    int a = 1;
  }
  unsafe { int b = 1; }
  // 修饰语句
  safe int c = 1;
  unsafe c++;
  // 修饰括号表达式
  char d = unsafe((char)c);
  return 0;
}
```

1. 不允许使用`safe/unsafe`修饰全局变量、函数外类型声明、`typedef`声明（允许修饰函数指针)。

```
// error: 不允许修饰全局变量
safe int g_a;
// error: 不允许修饰函数外类型声明
safe struct b { int a; };
// error: 不允许修饰 typedef
safe typedef int mm;

int main() { return 0; }
```

1. `safe`修饰的函数，参数类型和返回类型必须是`safe`类型。

   非`safe`类型包括：裸指针类型、`union`类型、成员中包含不安全类型的`struct`类型、成员中包含不安全类型的数组类型。

```
// error: 返回值为非安全类型的裸指针类型
safe int *test1(int a);
// error: 参数类型为非安全类型的裸指针类型
safe int test2(int *a);

typedef struct F {
  int *a;
} SF;
// error: 返回值为成员中包含不安全裸指针类型的 struct 类型
safe SF test3(int a);
// error: 参数类型为成员中包含不安全裸指针类型的 struct 类型
safe int test4(SF b);
```

1. `safe`修饰的函数，函数参数列表不可以省略。`safe void test(); `是不允许的， `safe void test(void); `是允许的。
2. `safe`修饰的函数，函数参数列表不可以包含变长参数。`safe int test(int a, ...); `是不允许的。
3. 如果`trait`中的函数被声明为`safe`，那么要求实现`trait`的类型的对应成员函数也必须是`safe`修饰的函数。若`trait`中的函数未声明为`safe`，也允许实现`trait`中的类型的成员函数为`safe`，但编译器会给出**warning**。

```
trait G {
  safe int *owned test1(This * owned this);
  int *owned test2(This * owned this);
};
// ok: trait 实现函数必须为 safe
safe int *owned int ::test1(int *owned this) { return this; }
// 非 safe 函数的实现可以为 safe
safe int *owned int ::test2(int *owned this) { return this; }
impl trait G for int;

int main() { return 0; }
```

1. 多个同名函数声明必须有同样的`safe/unsafe`修饰。

```
safe int test(int a);
// error: 多个函数声明中 safe/unsafe 不一致
unsafe int test(int a);
```

1. 多个同名函数声明排除`safe/unsafe`修饰后，应是完全一致的。

```
safe int test(int a);
// error: 函数声明不完全一致
safe int test(int a, int b);
```

1. `safe`修饰泛型函数时，会对泛型每个实例化版本也做`safe`检查。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe T F<T>(T a) { return a; }

void test() {
  int a = 1;
  int b = F<int>(a);
  int *owned c = (int *owned)safe_malloc(1);
  int *owned d = F<int * owned>(c);
  // error: 实列化函数入参和返回值为非安全的裸指针类型
  int *e = F<void *>((void *)0);
  safe_free((void *owned)d);
}

int main() {
  test();
  return 0;
}
```

1. 成员函数也可以被`safe/unsafe`修饰，其规则和全局函数一样。

```
struct MyStruct<T> {
  T res;
};
safe T struct MyStruct<T>::foo_a(T a) {
  return a;
}

int main() { return 0; }
```

1. 对于`safe`修饰的函数指针类型，与赋值的函数参数和返回值类型必须是一致的。

```
safe void test1(int a) {}
safe void test2(void) {}
void test3(void) {}
safe void (*p)(int a);
int main() {
  p = test1;
  // error: 参数类型不一致，不允许赋值
  p = test2;
  // error: 参数类型不一致，不允许赋值
  p = test3;
  return 0;
}
```

1. 安全区内被调用的函数或函数指针必须是`safe`的函数签名，不允许调用非安全函数或函数指针。

```
safe void test1(void) {}
unsafe void test2(void) {}
safe void (*test3)(void);
unsafe void (*test4)(void);
int main() {
  safe {
    test1();
    // error: 安全区内不允许调用非安全函数
    test2();
    test3();
    // error: 安全区内不允许调用非安全函数指针
    test4();
  }
  unsafe {
    test1();
    test2();
    test3();
    test4();
  }
}
```

1. 安全区内允许再包含`unsafe`修饰的语句、函数指针、括号表达式，非安全区内也允许再包含`safe`修饰的语句、函数指针、括号表达式。

```
int test1(int a, int b) { return a + b; }
safe int test2(int a, int b) { return a > b ? a : b; }
int main() {
  safe {
    int a = 0;
    unsafe a++;
    unsafe {
      a = test1(1, 3);
      safe a = test2(3, 5);
    }
  }
}
```

1. 安全区内不允许无初始化或初始化不完整的变量声明。

```
struct S {
  int age;
  char name[20];
};
void test() {
  safe {
    // error: 安全区内不允许无初始化的变量声明
    int a;
    // error：安全区不允许部分初始化
    struct S tom = {10};
    struct S tony = {10, "tony"};
  }
}

int main() {
  test();
  return 0;
}
```

1. 安全区内`switch`语句中的`case/default`只能存在于`switch`后面的第一层代码块中，且第一层代码块不允许有变量定义。

```
safe void test(int a) {
  switch (a) {
    // error: 第一层代码块不允许有变量定义
    int b = 10;
    case 0: {
        int c = 1;
        break;
    }
    {
        // error: case 只能存在于 switch 后面的第一层代码块中
        case 1 : { break; }
    }
    {
        // error: default 只能存在于 switch 后面的第一层代码块中
        default: { break; }
    }
  }
}

int main() {
  int a = 1;
  test(a);
  return 0;
}
```

1. 安全区内不允许使用自增 （++）、自减（--）操作符，不允许使用`union`，不允许裸指针通过`->`访问成员，

   允许owned指针和borrow指针通过`->`访问成员。

```
union un {
  int age;
  char name[16];
};
struct F {
  int age;
};

void test(void) {
  struct F d = {10};
  struct F *e = &d;
  struct F *owned f = (struct F * owned) & d;
  struct F *borrow i = &mut d;
  safe {
    int a = 1;
    // error: 安全区不允许自增
    a++;
    // error: 安全区不允许自减
    a--;
    // ok: 安全区允许 += 运算符
    a += 1;
    // ok: 安全区允许 -= 运算符
    a -= 1;
    // error: 安全区不允许使用 union
    union un b = {10};
    // error: 安全区不允许 union 通过“.”访问成员
    int c = b.age;
    // error: 安全区不允许裸指针通过“->”访问成员
    int g = e->age;
    // ok: 允许owned指针“->”通过访问成员
    int h = f->age;
    // ok: 允许borrow指针“->”通过访问成员
    int j = i->age;
  }
}

int main() {
  test();
  return 0;
}
```

1. 安全区内不允许使用取地址符`&`（允许对函数取地址），只允许`&const`，`&mut`取借用。

   安全区内不允许解引用裸指针类型，但可以解引用`owend`指针类型和`borrow`指针类型。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

void test() {
  safe {
    int a = 10;
    // error: 安全区不允许取地址符号
    int *b = &a;
    // error: 安全区不允许解引用裸指针
    int c = *b;
    int *owned d = safe_malloc(2);
    // ok: 允许解引用owned指针
    int e = *d;
    safe_free((void *owned)d);
    int *borrow f = &mut a;
    // ok: 允许解引用borrow指针
    int g = *f;
  }
}

int main() {
  test();
  return 0;
}
```

1. 安全区内不允许指向类型不同的指针类型之间转换，但允许其他类型owned指针显式转换为void类型的owned指针。

   安全区内不允许指针和非指针类型之间的转换，不允许`owned/borrow/raw`指针之间的转换。

```
void test() {
  int *pa;
  double *pb;
  safe {
    // error：不允许指向类型不同的指针类型之间转换
    pb = pa;
    // error：不允许指向类型不同的指针类型之间转换
    pa = pb;
    // error：不允许指向类型不同的指针类型之间转换
    pb = (double *)pa;
  }
  int i;
  safe {
    // error：不允许指针和非指针类型之间的转换
    pa = i;
    // error：不允许指针和非指针类型之间的转换
    i = pa;
  }
  int *owned pd = (int *owned)pa;
  safe {
    // error：不允许 owned/raw 指针之间的转换
    pa = pd;
    // error：不允许 owned/raw 指针之间的转换
    pd = pa;
    // ok : 允许显式转换为void类型的owned指针
    void *owned pe = (void *owned)pd;
  }
}

int main() {
  test();
  return 0;
}
```

1. 安全区内不允许表达范围从大向小的类型转换（比如从`long`转换为`int`，从`int`转换为`_Bool`，从`int`转换为`enum`）。不允许表达精度从高向低的类型转换（比如从`double`转换为`float`）。对于基础类型的常量发生类型转换，如果目标类型可以描述这个值，那么该类型转换是允许的，并且在`if/while`中也允许转换。

```
void test() {
  long a;
  int b;
  _Bool c;
  double e;
  float f;
  safe {
    // ok: 允许表达范围从小向大的类型转换
    a = b;
    // error: 不允许表达范围从大向小的类型转换
    b = a;
    a = 1;
    // _Bool可以描述1
    c = 1;
    // error: 目标类型不可以描述这个值，不允许转换
    c = 2;
    e = f;
    // error：不允许表达精度从高向低的类型转换
    f = e;
    f = 1.0;
    f = 1.2f;
  }
}

int main() {
  int a = 2;
  safe {
    // ok: 在 if 中允许转换
    if (a) {
      a += 1;
    } else {
      a -= 1;
    }
  }
  test();
  return 0;
}
```

1. 安全区内不允许内嵌汇编语句。

```
void test() {
  safe {
    int ret = 0;
    int src = 1;
    // error: 安全区不允许内嵌汇编
    asm("move %0, %1\n\t" : "=r"(ret) : "r"(src));
  }
}
int main() { return 0; }
```

### 所有权

#### 0. 前言

C 语言作为一种系统级编程语言， 提供了对指针的高度灵活的直接操作以及利用内存管理函数使开发者手动精细控制和管理内存的能力， 因而被广泛地应用于各种需要直接与硬件或内存等系统资源交互的领域和场景。 然而，这种内存管理模式存在容易导致内存泄漏、释放后使用、空指针解引用、缓冲区溢出和越界读写等内存安全问题。 内存安全问题不仅会造成资源的浪费，也可能导致程序行为错误，甚至导致程序崩溃，对程序的稳定性造成威胁。 内存安全问题可以划分为**时间内存安全**和**空间内存安全**两大类，其中时间内存安全包含内存泄漏、释放后使用、空指针解引用等，空间内存安全包括缓冲区溢出、越界读写等。 BiShengC 语言的内存管理为解决程序的时间内存安全问题，利用了**所有权特性**在编译期对潜在的内存安全问题进行检查，识别潜在的时间内存安全错误。

#### 1. 特性简介

BiShengC 语言的所有权特性被用于确保程序中的指针及其指向内存空间能被正确地管理。 在 BiShengC 语言中，使用`owned`关键字用来修饰一个指针类型，表明该指针拥有其指向的内存的所有权。 拥有所有权的指针必须确保其指向的内存在指针作用域结束前被显式释放，否则存在潜在的内存泄漏错误； 此外，一块堆内存只能同时被一个`owned`指针所拥有，`owned`指针为移动语义，这样避免了释放后使用等内存安全问题的发生。 以下是一段使用了所有权特性的 BiShengC 语言代码，用于了解所有权特性：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

int *owned takes_and_gives_back(int *owned p) { return p; }

safe void test(void) {
  // 通过提供的 safe_malloc 申请一块大小为 sizeof(int) 的堆内存，并将值设置为2
  int *owned p = safe_malloc(2);
  // 将 p 指向的堆内存转移给 q，后续不可再使用 p 访问这块内存，否则编译报错
  int *owned q = p;
  unsafe {
    // 通过函数参数转移走 q 的所有权，但通过函数返回值归还所有权
    q = takes_and_gives_back(q);
    // 在 q 的作用域结束前调用 safe_free
    // 安全释放堆内存，此处不释放则会报内存泄漏错误
    safe_free((void *owned)q);
  }
  return;
}

int main() {
  test();
  return 0;
}
```

在安全区，`owned`指针指向的内存一定为堆上内存（如通过`safe_malloc`函数申请出的堆内存），`owned`指针不可能指向栈内存，在作用域结束前必须转移所有权或释放（如`safe_free`函数进行释放）。

这两个函数的函数原型如下：

```
T *owned safe_malloc<T>(T t);
void safe_free(void *owned);
```

可以通过`safe_malloc`申请足够存放`T`类型的堆空间，并初始化为`t`，当`owned`指针生命周期结束前，必须通过`safe_free`进行释放，在使用时，需要将`T *owned`指针转换为`void *owned`指针类型再释放，对于**多级指针，需要从内到外进行释放**；对于结构体内部有`owned`指针成员的情况，需要**先将结构体内全部`owned`指针成员释放后，才能释放结构体的`owned`指针**。

函数使用示例：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

safe void test(void) {
  //变量所有权初始化
  int *owned pi = safe_malloc(1);
  // 结构体所有权初始化
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  struct S *owned s1 = safe_malloc(s);
  // 多级指针所有权初始化
  int *owned p = safe_malloc(1);
  int *owned *owned pp = safe_malloc(p);
  // 变量所有权释放
  safe_free((void *owned)pi);
  // 结构体所有权释放(从内到外)
  safe_free((void *owned)s1->p);
  safe_free((void *owned)s1->q);
  safe_free((void *owned)s1);
  // 多级指针所有权释放(从内到外)
  safe_free((void *owned) * pp);
  safe_free((void *owned)pp);
}

int main() {
  test();
  return 0;
}
```

#### 2. 语法及语义规则

为实现所有权特性，BiShengC 语言引入了`owned`关键字用于修饰指针类型的变量。 该关键字与`const`、`restrict`以及`volatile`均属于类型修饰符，其语法如下：

```
type-qualifier:
  const | restrict | volatile | ownership-qualifier

ownership-qualifier:
  owned
```

具体而言，所有权特性的语法及部分语义规则有以下几点：

1. `owned`关键字仅允许在 BiShengC 语言编译单元内使用；
2. `owned`关键字仅被允许用于修饰指针类型，不允许修饰非指针类型，修饰多级指针时，每级指针的类型修饰可以不一样，规则与`const`类似；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe int main(void) {
  int *owned p = safe_malloc(2);
  // error: owned 关键字必须修饰指针
  int owned a = 2;
  double *owned q = safe_malloc(1.1);
  // error: owned 关键字必须修饰指针
  double owned b = 1.1;
  // ok: 可以修饰多级指针
  int *owned *owned pp = safe_malloc(p);
  double *d = (double *)malloc(sizeof(double));
  double **owned pd = safe_malloc(d);
  // error: 多级指针释放时，应当释放从内向外释放
  safe_free((void *owned) * pp);
  safe_free((void *owned)pp);
  free(*pd); // 也可直接 free(d);
  safe_free((void *owned)pd);
  safe_free((void *owned)q);
  return 0;
}
```

1. 允许使用`owned`关键字修饰结构体指针及结构体的指针成员；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int m;
  int n;
};

struct R {
  int *owned p;
  double *owned q;
};

safe void test(void) {
  struct S s = {.m = 1, .n = 2};
  struct S *owned sp = safe_malloc(s);
  // error: 要用 owned 不允许修饰结构体变量
  struct S owned so = {.m = 1, .n = 2};
  struct R r = {.p = safe_malloc(1), .q = safe_malloc(2.5)};
  struct R *owned rp = safe_malloc(r);
  safe_free((void *owned)sp);
  // 先释放结构体内的 owned 指针成员
  safe_free((void *owned)rp->p);
  safe_free((void *owned)rp->q);
  // 再释放结构体 owned 指针
  safe_free((void *owned)rp);
}

int main() {
  test();
  return 0;
}
```

1. `owned`不允许修饰`union`类型和`union`的成员，且`union`的每个成员均不能拥有`owned`修饰的成员；

```
struct S {
  int a;
  int b;
};

struct T {
  int *owned p;
  struct S s;
};

union A {
  int a;
  // error: 禁止 union 成员用 owned 修饰
  int *owned p;
  struct S s;
  // error: 禁止 union 成员用 owned 修饰
  struct S *owned sp;
  // error: 禁止 union 成员结构体有 owned 成员
  struct T t;
  // error: 禁止 union 成员用 owned 修饰
  struct T *owned tp;
  // ok: 不跟踪裸指针指向的变量的 owned 成员
  struct T *trp;
};
```

1. `owned`修饰的类型或拥有`owned`修饰的成员的类型不可以作为数组的成员；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct A {
  int *owned p;
};

safe void test(void) {
  // error: 数组成员不能被 owned 修饰
  int *owned arr_i[2] = {safe_malloc(1), safe_malloc(2)};
  // error: 数组成员不能被 owned 修饰
  struct A arr_a[2] = {{safe_malloc(1)}, {safe_malloc(2)}};
}
```

1. `owned`修饰的指针不支持算术运算符（指针偏移操作），但支持比较运算符；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe int main(void) {
  int *owned p = safe_malloc(2);
  int *owned q = safe_malloc(3);
  // error: owned 指针不支持算术运算符
  p += 1;
  // error: owned 指针不支持 [] 运算符
  p[3] = 3;
  // error: owned 指针支持比较运算符
  if (p == q) {
  }
  unsafe {
    safe_free((void *owned)p);
    safe_free((void *owned)q);
  }
  return 0;
}
```

1. `owned`修饰的类型与非`owned`修饰的类型之间不允许隐式类型转换；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe int main(void) {
  unsafe {
    int *b = (int *)malloc(sizeof(int));
    // error: owned 指针不允许隐式类型转换
    int *owned p = b;
  }
  int *owned q = safe_malloc(3);
  // error: owned 指针不允许隐式类型转换
  int *c = q;
  safe_free((void *owned)q);
  return 0;
}
```

1. 基本类型一致时，允许`owned`指针类型与非`owned`指针类型之间的显式强制类型转换，且这种转换只能在非安全区进行； 基本类型不一致时，只允许`void * owned`类型与`T * owned`类型之间的相互强制转换；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

int main() {
  int *i = (int *)malloc(sizeof(int));
  // ok: i 和 pi 的基本类型均为 int
  int *owned pi = (int *owned)i;
  double *d = (double *)malloc(sizeof(double));
  // error: d 和 pd 基本类型不一致
  int *owned pd = (int *owned)d;
  double *owned dd = safe_malloc(1.5);
  // ok: 允许显式转换为 void *owned
  void *owned pdd = (void *owned)dd;
  safe_free((void *owned)pi);
  safe_free((void *owned)d);
  safe_free((void *owned)pdd);
  return 0;
}
```

1. `owned`允许修饰指向`trait`的指针，假设有一个具体类型`S`，它实现了`trait T`，则：
   - `S * owned`类型可以隐式转换为`trait T * owned`类型；
   - `trait T * owned`类型允许被显式转换为`void * owned`类型。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

trait T{};

impl trait T for int;

void test() {
  int *owned pi = safe_malloc(1);
  // ok: 隐式转换为 trait T *owned
  trait T *owned pti = pi;
  // ok: 显式转换为 void *owned
  void *owned pvi = (void *owned)pti;
  safe_free(pvi);
}

int main() {
  test();
  return 0;
}
```

1. 通过函数指针调用函数的时候，规则与一般的函数调用一样，会在函数调用时检查形参类型与实参类型是否匹配及返回类型与返回值类型是否匹配；

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

int add(int *a, int *b) { retun *a + *b; }
typedef int (*FTP)(int *, int *);
typedef int (*FTOP)(int *owned, int *);

void test() {
  FTP ftp = add;
  int *owned pa = safe_malloc(1);
  int *owned pb = safe_malloc(2);
  // error: 类型不匹配
  ftp(pa, pb);
  // error: 类型不匹配
  FTOP ftop = add;
  safe_free((void *owned)pa);
  safe_free((void *owned)pb);
}

int main() {
  test();
  return 0;
}
```

1. `owned`可以修饰 trait 类型，即`trait T* owned`，也表示该变量拥有其内部存储的数据的所有权。 该类型可以作为类型声明、函数的入参类型及函数的返回值类型。但当前不支持`trait T* owned`与`trait T*`之间的类型转换。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

trait T { safe void release(This * owned this); };
struct IPv4 {
  char *buf1;
};
struct IPv6 {
  char *buf1;
  char *buf2;
};
safe void struct IPv4::release(struct IPv4 *owned this) {
  unsafe { free(this->buf1); }
  safe_free((void *owned)this);
}
safe void struct IPv6::release(struct IPv6 *owned this) {
  unsafe {
    free(this->buf1);
    free(this->buf2);
  }
  safe_free((void *owned)this);
}
impl trait T for struct IPv4;
impl trait T for struct IPv6;

void cleanup(trait T *owned t) { t->release(); }

int main() {
  struct IPv4 ipv4 = {.buf1 = "192.168.1.1"};
  struct IPv6 ipv6 = {.buf1 = "2001:0db8:85a3:0000",
                      .buf2 = "0000:8a2e:0370:7334"};
  struct IPv4 *owned sipv4 = safe_malloc(ipv4);
  struct IPv6 *owned sipv6 = safe_malloc(ipv6);
  trait T *owned tipv4 = sipv4;
  trait T *owned tipv6 = sipv6;
  // 使用 trait T* owned 作为入参
  tipv4->release();
  tipv6->release();
  safe_free((void *owned)tipv4);
  safe_free((void *owned)tipv6);
  return 0;
}
```

#### 3. 所有权状态转移规则

在对所有权特性的语法和部分语义有了解后，本节将对所有权的状态转移规则进行详细阐述。 为更好地理解所有权特性对内存安全带来的保障，首先需要明白程序执行时的堆栈内存模型。

总体而言，程序执行时内存可分为栈区和堆区两个部分，这两部分内存一起为程序在运行时提供内存空间。 栈区即为调用栈，保存的是程序执行所需要维护的所有信息。 每当一次函数调用发生时，就会创建一个对应的栈帧，函数调用的上下文、函数的入参以及函数体内的局部变量就存在这个栈帧中。 栈帧的基址一般由 rbp 寄存器指向，而栈顶由 rsp 寄存器指向，两个寄存器共同标识了一个函数的栈帧。 当一次函数调用结束时，相应的栈帧就会在函数返回前被销毁，相应的内存空间也就得到释放。 这个过程是通过调整 rbp 寄存器的值为调用者的栈帧基址、rsp 的值为调用者的栈顶地址完成的，这也是为什么栈区的变量不需要显式释放。 对于堆区，则存放的是那些在运行时动态分配内存的数据。 一个典型的例子是对于`int *p = malloc(sizeof(int))`这种操作，需要由操作系统在堆区找到一块适合大小的内存空间用于分配，然后将这块内存的地址存在 p 中，指针 p 是程序的一个栈上变量。 虽然堆区的内存分配更为灵活，但却缺乏组织，不正确的内存管理很容易导致堆区的内存泄漏。 例如，当一次函数调用完成后，其局部变量 p 被销毁，而其指向的堆内存未被显式地调用`free(p)`进行回收，则这块堆内存将永远无法被回收，产生了内存安全错误。

![img](https://gitee.com/bisheng_c_language_dep/llvm-project/raw/bishengc/15.0.4/clang/docs/BiShengCLanguageUserManualImages/memory-leak-example.png)

利用 BiShengC 语言提供的所有权特性，可以用`owned`关键字对那些需要管理的指针进行标识，这样就可以在程序编译时检查出潜在的错误，避免在运行时出现错误。 以下是 BiShengC 语言所有权的核心规则：

1. 在 BiShengC 语言中每一个值都被一个`owned`指针变量所拥有，该`owned`指针变量即为值的所有者；
2. 一个值同时只能被一个`owned`指针变量所拥有，即一个值只能拥有一个所有者；
3. 当`owned`指针变量离开作用域范围时，需要释放其拥有的值所在的堆内存。

基于以上核心规则，接下来结合详细的代码示例进行具体介绍。

##### 3.1 转移所有权

**1. 一个拥有所有权的变量`s1`被赋值给另一个变量`s2`是一个移动语义，该操作后变量`s1`失去了对值的所有权，原先的变量`s1`无法再使用。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe void test(void) {
  int *owned p = safe_malloc(10);
  int *owned q = p;
  // error: p 的所有权已移交给q了
  int *owned m = p;
  unsafe {
    safe_free((void *owned)q);
    safe_free((void *owned)m);
  }
}

int main() {
  test();
  return 0;
}
```

在这个例子中，`p`拥有一块堆内存的所有权，这块内存大小为`sizeof(int)`，存储的值为10。 在声明`q`时，将`p`的所有权转移给了`q`，`p`不再拥有对这块堆内存的所有权。 则在声明`m`时，便不可再将`p`的所有权转移给`m`，编译器会在此处报错。 因此，利用所有权特性，可以保证一个值只能拥有一个所有者。 （那么如果没有这条规则会出现什么后果呢？三个指针会同时指向一块内存，在作用域结束时对这块内存释放三次，出现重复释放的错误）

**2. 一个拥有所有权的变量`s1`作为整体被赋值给另一个变量`s2`时，如果`s1`内部还有其他拥有所有权的指针，则会全部都转移给`s2`。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *p;
  int *owned q;
};

void test(void) {
  struct S s = {.p = (int *)malloc(sizeof(int)), .q = safe_malloc(1)};
  struct S *owned s1 = safe_malloc(s);
  struct S *owned s2 = s1;
  // error: q 的所有权被一并交给 s2 了
  int *owned p = s1->q;
  safe_free((void *owned)s2->q);
  safe_free((void *owned)s2);
  safe_free((void *owned)p);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，将`s1`指向堆内存的所有权转移给了`s2`，但同时`s1`内部还有一个拥有所有权的指针`s1->q`，因此也会一并将他的所有权转移给`s2->q`，后续再使用`s1->q`时便会报错。

**3. 一个拥有所有权的变量`s1`作为整体被赋值给另一个变量`s2`时，如果`s1`内部还有其他拥有所有权的指针，则必须保证内部其他`owned`指针均拥有所有权，才能将`s1`赋值给`s2`。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

safe void test(void) {
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  struct S *owned s1 = safe_malloc(s);
  int *owned p = s1->p;
  // error: s1 已无对全部成员的所有权
  struct S *owned s2 = s1;
  safe_free((void *owned)p);
  safe_free((void *owned)s2->p);
  safe_free((void *owned)s2->q);
  safe_free((void *owned)s2);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，我们先将`s1->p`的所有权转移走，然后试图整体转移`s1`的所有权给`s2`，但此时`s1->p`已经不再持有对任何一块堆内存的所有权，因此这个操作是不合法的。

**4. 一个拥有所有权的变量`s1`在失去其所有权后，可以通过赋值的方式使其再次拥有指向某块堆内存的所有权，这样就可以再次使用`s1`。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe void test(void) {
  int *owned p = safe_malloc(10);
  // 移走 p
  int *owned q = p;
  // 重新拿到新元素的所有权
  p = safe_malloc(4);
  // 仍然可以将所有权交给其他指针
  int *owned m = p;
  safe_free((void *owned)q);
  safe_free((void *owned)m);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，`p`的所有权转移给`q`后，再次调用了`safe_malloc`函数为其重新赋予了一块堆内存的所有权，因此后续仍可将`p`的所有权转移给`m`。

**5. 不允许将所有权转移给一个已经拥有所有权的变量。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

safe void test(void) {
  int *owned p = safe_malloc(12);
  int *owned q = safe_malloc(67);
  // error: p 有拥有其他指针的所有权
  q = p;
  safe_free((void *owned)p);
  safe_free((void *owned)q);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，试图将`p`的所有权转移给`q`，但`q`此时已经拥有所有权，再试图转移的话会使`q`原先指向的堆内存泄漏，因此无法进行转移，会在编译时报错。

**6. 如果一个变量`s1`拥有所有权，而其内部的`owned`指针变量的所有权已被转移，如果想再次赋予内部变量所有权，需要保证内部变量的所有父`owned`指针变量均拥有所有权。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

safe void test(void) {
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  struct S *owned s1 = safe_malloc(s);
  struct S *owned s2 = s1;
  // error: s1 已不再拥有所有权，无法给内部成员赋予所有权
  s1->p = safe_malloc(5);
  safe_free((void *owned)s2->p);
  safe_free((void *owned)s2->q);
  safe_free((void *owned)s2);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，`s1`、`s1->p`以及`s1->q`的所有权均被转移给了`s2`，后续再试图赋予`s1->p`所有权时，其父`owned`变量指针`s1`尚未拥有所有权，因此此次操作是非法的，会在编译时报错。

##### 3.2 作用域结束时的内存释放

**1. 对于所有的`owned`指针变量，会在其词法作用域结束时检查其是否依然拥有堆内存的所有权，如果依然拥有，则存在内存泄漏错误。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

safe void test(void) {
  int *owned p = safe_malloc(2);
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  struct S *owned s1 = safe_malloc(s);
  struct S *owned s2 = s1;
  // error: 未释放 s2 内部成员所有权及 s2 所有权；未释放 p 所有权
  // safe_free((void *owned)p);
  // safe_free((void *owned)s2->p);
  // safe_free((void *owned)s2->q);
  // safe_free((void *owned)s2);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，当作用域结束时，编译器会发现`p`、`s2`、`s2->p`以及`s2->q`依然拥有其指向的堆内存的所有权，即这些堆内存都没有被释放，因此会编译失败并报告内存泄漏。

##### 3.3 强制类型转换

**1. 允许将`T \* owned`类型的变量通过强制类型转换转为`void \* owned`类型，但转换成功的条件为变量依然拥有所有权且其内部的`owned`指针变量均已不拥有所有权。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

safe void test(void) {
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  struct S *owned s1 = safe_malloc(s);
  int *owned p = s1->p;
  unsafe {
    // error: s1 仍然拥有内部成员(q)所有权，无法转为 void *owned
    safe_free((void *owned)s1);
    safe_free((void *owned)p);
  }
}

int main() {
  test();
  return 0;
}
```

在这个例子中，试图将`s1`强制类型转换为`void * owned`类型，但`s1->q`依然拥有所有权，因此转换失败。

##### 3.4 函数调用与返回

**1. 函数调用和返回时，如果函数的形参或函数的返回值为`owned`指针类型，则要求传入的实参以及返回值必须拥有堆内存的所有权。** 以下是一段代码示例及说明：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct S {
  int *owned p;
  int *owned q;
};

struct S *owned F(struct S s) {
  struct S *owned ret = safe_malloc(s);
  return ret;
}

void test(void) {
  struct S s = {.p = safe_malloc(2), .q = safe_malloc(3)};
  int *owned p = s.p;
  // error: s 已不再拥有全部内部成员的所有权
  struct S *owned s1 = F(s);
  safe_free((void *owned)p);
  safe_free((void *owned)s1->p);
  safe_free((void *owned)s1->q);
  safe_free((void *owned)s1);
}

int main() {
  test();
  return 0;
}
```

在这个例子中，传入`F`函数的结构体变量`s`内部有两个`owned`指针变量，而`s.p`已经被转移走，因此这次函数调用是非法的，会编译报错。

#### 4. 源源变换

BiShengC 语言的 clang 编译器支持源源变换功能，即将`.cbs`文件转换为等价的`.c`文件。 所有权特性仅引入了`owned`关键字表示所有权，在源源变换时只会去掉所有的`owned`关键字，然后生成相应的`.c`代码。 关于源源变换的详细细节，请参考手册的源源变换章节。

### 借用

借用作为毕昇C内存安全特性的重要组成部分，是对所有权的一个补充。前面小节描述了所有权特性(ownership)，对某个资源拥有所有权的主体，有责任释放这个资源。这个小节，将介绍对资源的借用(borrow)。

#### 1. 特性简介

如果我们只有 ownership 类型，由于函数调用、赋值等操作都会转移所有权，那么代码能力会非常受限。在编程时，我们常常需要表达“对某个资源进行借用”的概念，区别于“拥有某个资源”。正如现实生活中，如果一个人拥有某样东西，你可以从他那里借来，当使用完毕后，也必须要物归原主。

#### 1.1 借用的定义及借用操作符

毕昇 C 的**借用是一个指针类型，指向了被借用对象存储的内存地址**。为表达借用的概念：

1. 引入新关键字`borrow`，用`borrow`来修饰指针类型 T*，表示 T 的借用类型
2. 引入借用操作符 `&mut` 和 `&const`，其中，`&mut e`表示获取对表达式 e 的**可变借用**，`&const e`表示获取对表达式`e`的**只读借用**。此处要求表达式`e`是 lvalue（左值）与标准 C 中的取地址操作符`&`类似, 借用操作符实际上获取的是表达式`e`的地址

例如，我们可以创建指向局部变量`local`的可变借用`p1`和不可变借用`p2`，并使用它们：

```
void use_immut(const int *borrow p) {}
void use_mut(int *borrow p) {}

void test() {
  int local = 5;
  // p1是local的可变借用指针
  int *borrow p1 = &mut local;
  use_mut(p1);
  // p2是local的不可变借用指针
  const int *borrow p2 = &const local;
  use_immut(p2);
}

int main() {
  test();
  return 0;
}
```

另外，表达式`e`如果是指针的解引用表达式，`&mut *p`和`&const *p`分别可以看作对地址`p`中存放的值，也就是`*p`，取可变借用和不可变借用，**这一操作不为`\*p`产生临时变量**。其中，`p`可以是裸指针、`owned`指针和其它借用指针。例如：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

void test() {
  int *x1 = malloc(sizeof(int));
  *x1 = 1;
  // p1借用了*x1
  int *borrow p1 = &mut * x1;
  int *owned x2 = safe_malloc(2);
  // p2借用了*x2
  int *borrow p2 = &mut * x2;
  int local = 3;
  int *borrow x3 = &mut local;
  // p3借用了*x3
  int *borrow p3 = &mut * x3;
  safe_free((void *owned)x2);
}

int main() {
  test();
  return 0;
}
```

#### 1.2 借用的作用

假设我们有这样的一个需求：创建一个文件，并且调用一些操作函数对文件进行读写操作。如果没有借用的概念，调用文件操作函数会导致文件指针所有权的转移，为了使文件指针在函数调用之后仍然可以被使用，我们需要再将所有权返回给调用方：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放
#include <stdio.h>

typedef struct {
  int file_id;
} MyFile;

MyFile *owned create_file(int id) {
  MyFile f = {.file_id = id};
  return safe_malloc(f);
}
void file_safe_free(MyFile *owned p) { safe_free((void *owned)p); }

MyFile *owned insert_str(MyFile *owned p, char *str) {
  // some operation to insert a string to file
  printf("%s to file %d\n", str, p->file_id);
  // 通过返回值，将所有权转移给调用方，避免所有权转移
  return p;
}

MyFile *owned other_operation(MyFile *owned p) {
  // some operation
  // 通过返回值，将所有权转移给调用方，避免所有权转移
  return p;
}

int main() {
  MyFile *owned p = create_file(0);
  char str[] = "insert str";
  // p的所有权先被移动到 insert_str 中，再通过返回值转移到调用方
  p = insert_str(p, str);
  p = other_operation(p);
  file_safe_free(p);
  return 0;
}
```

这种写法会造成文件指针所有权的频繁转移，在代码逻辑较为复杂的时候很容易出错，而且如果所有权被转移走了但是没有归还，后续将无法再使用该文件指针。有了借用，将对文件指针的借用作为参数传递给操作函数，函数返回之后文件指针仍可以用于后续其他操作，不再需要像上面那个例子一样，先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放
#include <stdio.h>

typedef struct {
  int file_id;
} MyFile;

MyFile *owned create_file(int id) {
  MyFile f = {.file_id = id};
  return safe_malloc(f);
}
void file_safe_free(MyFile *owned p) { safe_free((void *owned)p); }

void insert_str(MyFile *borrow p, char *str) {
  // some operation to insert a string to file
  printf("%s to file %d\n", str, p->file_id);
  // 无需返回所有权
}

void other_operation(MyFile *borrow p) {
  // some operation
  // 无需返回所有权
}

int main() {
  MyFile *owned p = create_file(0);
  char str[] = "insert str";
  // 所有权不会被移动
  insert_str(&mut * p, str);
  // 所有权不会被移动
  other_operation(&mut * p);
  file_safe_free(p);
  return 0;
}
```

#### 2.借用变量和被借用对象的生命周期

##### 2.1 生命周期及其作用

我们可以对不同种类的对象取借用：`owned`变量、非`owned`类型的局部变量、全局变量、临时匿名变量、参数等，甚至是某个复合变量的一部分。为正确表示借用变量和不同种类被借用对象的有效作用域，我们引入生命周期的概念。

生命周期检查的主要作用是避免悬垂指针，它会导致程序使用本不该使用的数据，以下 C 代码就是一个使用了悬垂指针的典型例子：

```
int main() {
  int *p;
  {
    int local = 5;
    p = &local;
  }
  *p = 1;
  return 0;
}
```

这段 C 代码有两点值得注意：

1. `int *p`的声明方式存在使用`NULL`的风险；
2. `p`指向了内部block中的`local` 变量，但是`local`会在block结束的时候被释放，因此回到外部block后，`p`会指向一个无效的地址，是一个悬垂指针，它指向了提前被释放的变量`local`，可以预料到，`*p = 1` 会导致该段程序运行时出现未定义行为（undefined behavior）。当代码逻辑较为复杂时，这类异常行为很难被发现。

对于第一点，毕昇 C 规定：和裸指针不同，表示借用的`borrow`指针必须被初始化，表示对某一个具体对象的借用；

对于第二点，毕昇 C 规定：**任何一个对资源的借用，都不能比资源的所有者的生命周期长**。也就是说：借用变量的生命周期，不能比被借用对象的生命周期长。

接下来我们使用毕昇 C 的借用特性改写上面的 C 代码，通过检查借用变量和被借用对象的生命周期，在编译期就可以识别出潜在的内存安全风险：

```
int main() {
  int local1 = 1;
  // 借用指针变量 p 必须被初始化，否则会报错
  int *borrow p = &mut local1;
  {
    int local2 = 2;
    // 对 p 进行再赋值之后，p 不再借用 local1，而是借用 local12
    p = &mut local2;
  }
  // error: local2 的生命周期不够长
  *p = 3;
  return 0;
}
```

##### 2.2 借用变量和被借用对象

每个借用变量（也就是 borrow 指针变量）都会有一个或多个被借用对象，例如：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

int g = 5;
void test(int a, int *owned b, int *c, struct S d) {
  // 被借用对象是普通局部变量
  int local = 5;
  int *borrow p1 = &mut local; // p1的被借用对象是local
  int *borrow p2 = &mut * p1;  // p2的被借用对象是*p1
  int *borrow p3 = p1;         // p3的被借用对象是*p1

  // 被借用对象是owned变量
  int *owned x1 = safe_malloc<int>(2);
  int *borrow p4 = &mut * x1; // p4的被借用对象是*x1

  // 被借用对象是裸指针变量
  int *x2 = malloc(sizeof(int));
  int *borrow p5 = &mut * x2; // p5的被借用对象是*x2

  // 被借用对象是结构体的某个字段
  struct S s = {.a = 5};
  int *borrow p6 = &mut s.a; // p6的被借用对象是s.a

  // 被借用对象是函数的返回值，与被调用函数的借用类型入参的 “被借用对象” 一样
  int local1 = 10, local2 = 20;
  // 被调用函数call有两个借用类型入参，因此p7的被借用对象是local1和local2
  int *borrow p7 = call(&mut local1, &mut local2);

  // 被借用对象是全局变量
  int *borrow p8 = &const g; // p8的被借用对象是g

  // 被借用对象是函数入参
  int *borrow p9 = &mut a;    // p9的被借用对象是a
  int *borrow p10 = &mut * b; // p10的被借用对象是*b
  int *borrow p11 = &mut * c; // p11的被借用对象是*c
  int *borrow p12 = &mut d.a; // p12的被借用对象是d.a
}

int main() {
  test();
  return 0;
}
```

##### 2.3 借用变量的 Non-Lexical Lifetime

一个变量的生命周期从它的声明开始，到当前整个语句块结束，这个设计被称为Lexical Lifetime，因为变量的生命周期是严格和词法中的作用域范围绑定的。这个策略实现起来非常简单，但它可能过于保守了，某些情况下借用变量的作用范围被过度拉长了，以至于某些实质上是安全的代码也被阻止了，这在一定程度上限制了程序员能编写出的代码。因此，毕昇 C 为借用变量引入 Non-Lexical Lifetime（简写为NLL），用更精细的手段计算借用变量真正起作用的范围，**借用变量的 NLL 范围为：从借用处开始，一直持续到最后一次使用的地方**。具体的，它是**从借用变量定义或被再赋值开始，到被再赋值之前最后一次被使用结束**。

其中，以下场景属于对借用变量p的使用：

1. 函数调用，如`use(p)`或`use(&mut *p)`
2. 函数返回`return p`或`return &mut *p`
3. 解引用`*p`
4. 成员访问`p->field`

举例来说：

```
void use(int *borrow p) {}
void other_op() {}

// 本例中p的NLL是分段的，每段NLL都有一个被借用对象
void test() {
  int local1 = 1, local2 = 2;  //#1
  int *borrow p = &mut local1; //#2，p的第一段NLL开始，被借用对象为local1
  other_op();                  //#3
  use(p);                      //#4，p的第一段NLL结束
  other_op();                  //#5
  p = &mut local2;             //#6，p的第二段NLL开始，被借用对象为local2，由于后面没有再对p的使用，p的NLL结束
  other_op();     //#7
}
// p的NLL是：[2,4]->local1, [6,6]->local2

int main() {
  test();
  return 0;
}
```

##### 2.4 被借用对象的 Lexical Lifetime

与借用变量不同，被借用对象的生命周期是 Lexical Lifetime，对于不同种类被借用对象的生命周期，我们给出具体的定义：

| 被借用对象种类 |                     | 生命周期定义                                                 |
| -------------- | ------------------- | ------------------------------------------------------------ |
| 全局变量       |                     | 全局变量的生命周期是整个程序，从程序开始到退出，一直存在     |
| 局部变量       | owned变量           | 从变量定义开始，到它被 move 走结束（owned struct类型如果没有被move，生命周期会在当前block结束的时候结束） |
|                | 非owned非borrow变量 | 从变量定义开始，到当前 block 结束                            |
| 局部字面量     | "string literal"    | 从使用处开始，到当前 block 结束的时候结束                    |
|                | (struct S) { ... }  | 从使用处开始，到当前 block 结束的时候结束                    |
| e->field       |                     | e 的生命周期                                                 |
| e.field        |                     | e 的生命周期                                                 |
| e[index]       |                     | e 的生命周期                                                 |
| *e             |                     | e 的生命周期                                                 |

#### 2.5 借用的生命周期约束

在2.1中我们提到过，对于借用，我们有这样的生命周期约束：**借用变量的生命周期，不能比被借用对象的生命周期长**。 举例来说：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

void use(int *borrow p) {}
int *borrow call(int *borrow p, int *borrow q) { return p; }

// 本例中，p的生命周期为[2,4]，被借用对象local的生命周期为[1,4]，满足生命周期约束
void test1() {
  int local = 5;              //#1
  int *borrow p = &mut local; //#2
  use(p);                     //#3
} //#4

// 本例中，p的生命周期有两段“
// ok: 第一段为[2,2]，被借用对象local的生命周期为[1,8]，满足生命周期约束
// error: 二段为[5,7]，被借用对象local1的生命周期为[4,6]，不满足生命周期约束
void test2() {
  int local1 = 5;              //#1
  int *borrow p = &mut local1; //#2
  {                            //#3
    int local2 = 5;            //#4
    p = &mut local2;           //#5
  }                            //#6
  use(p);                      //#7
} //#8

// 本例中p的生命周期有两段：
// ok: 第一段为[2,2]，被借用对象local的生命周期为[1, 8]，满足生命周期约束
// error: 第二段为[5,7]，被借用对象有两个，分别是local和local1，其中local1的生命周期为[4, 6]，不满足生命周期约束
void test3() {
  int local1 = 5;                       //#1
  int *borrow p = &mut local1;          //#2
  {                                     //#3
    int local2 = 5;                     //#4
    p = call(&mut local1, &mut local2); //#5
  }                                     //#6
  use(p);                               //#7
} //#8

// 本例中，if分支对p进行了重新赋值，在#10
// error: use(p)时，p的被借用对象local2的生命周期已经结束，不满足生命周期约束
// ok" else分支满足生命周期约束
void test4() {
  int local = 5;              //#1
  int *borrow p = &mut local; //#2
  int local1 = 5;             //#3
  if (rand()) {               //#4
    int local2 = 5;           //#5
    p = &mut local2;          //#6
  } else {                    //#7
    p = &mut local1;          //#8
  }                           //#9
  use(p);                     //#10
}

//本例中，p的生命周期为[2,4]，被借用对象*x的生命周期为[1,3]，不满足生命周期约束，error
void test5() {
  int *owned x = safe_malloc<int>(5); //#1
  int *borrow p = &mut * x;           //#2
  safe_free((void *owned)x);          //#3
  use(p);                             //#4
} //#5

int main() {
  test1();
  test2();
  test3();
  test4();
  test5();
  return 0;
}
```

#### 3.可变借用和不可变借用

毕昇 C 将借用指针的权限进行了分级，分为可变（mut）借用和不可变（immut）借用，我们可以通过操纵可变借用指针来读写被借用对象的内容，通过不可变借用指针，我们只能读取被借用对象的内容，但是不能修改它。例如：

```
// 可变借用指针类型为 T *borrow
void use_mut(int *borrow p) {
  // 通过可变借用指针，可以修改被借用对象的值
  *p = 5;
  // 通过可变借用指针，可以读取被借用对象的值
  int a = *p;
}

// 不可变借用指针类型为 const T *borrow
void use_immut(const int *borrow p) {
  // error: 无法通过不可变借用指针，来修改被借用对象的值
  *p = 5;
  // 通过不可变借用指针，可以读取被借用对象的值
  int a = *p;
}

int main() {
  int i = 1;
  int *borrow pmi = &mut i;
  use_mut(pmi);
  const int *borrow pimi = &const i;
  use_immut(pimi);
  return 0;
}
```

##### 3.1 `&mut e`要求 e 是可修改的

我们在 1.1 中提到过，`&mut e`和`&const e`要求表达式 e 是 lvalue，即 e 是可以被取地址的，对于可变借用表达式`&mut e`，我们还要求 e 是可变的，具体的：

| lvalue表达式       | 是否可修改                                                   |
| ------------------ | ------------------------------------------------------------ |
| ident              | 变量 ident 没有被 const 修饰，且ident 不能是函数名           |
| "string literal"   | 不允许，因为字符串常量保存在常量区，不能写                   |
| (struct S) { ... } | 允许                                                         |
| e->field           | 要求 e 是可变借用指针，或者是指向可修改类型的 owned 指针，或者是指向可修改类型的裸指针，且field没有被const修饰，多级 field 的情况应该要求每一级的 field 都没有 const 修饰 |
| e.field            | 要求 e 是可变的，且field没有被const修饰，多级 field 的情况应该要求每一级的 field 都没有 const 修饰 |
| e[index]           | 要求 e 是可变的                                              |
| *e                 | 要求 e 是可变借用，或者是指向可修改变量的裸指针              |

##### 3.2 可变借用同时只能存在一个

如果有两个或更多的指针同时访问同一数据，并且至少有一个指针被用来写入数据，可能会导致未定义行为，例如：

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放
#include <stdio.h>

void free_a(int *a) { free(a); }
void read_a(int *a) { printf("%d\n", *a); }

void test() {
  int *a = malloc(sizeof(int));
  *a = 42;
  int *p1 = a;
  int *p2 = a;
  // 该函数会释放 a 所指向的内存
  free_a(p1);
  // 该函数会读取 a 所指向的内存
  read_a(p2); // 打印一个脏值
}

int main() {
  test();
  return 0;
}
```

由于借用本质上也是指针，所以为了避免上述问题，毕昇 C 规定，**同一时刻，对于同一个对象，要么只能拥有一个可变借用, 要么任意多个不可变借用**。

```
void write(int *borrow p) {}
void read(const int *borrow p) {}

void test1() {
  int local = 1;
  int *borrow p1 = &mut local;
  // error: 同一时刻最多只能有一个指向local的可变借用变量
  int *borrow p2 = &mut local;
  write(p1);
  write(p2);
}

void test2() {
  int local = 1;
  int *borrow p1 = &mut local;
  // error: 指向local的可变和不可变借用不能同时存在
  const int *borrow p2 = &const local;
  write(p1);
  read(p2);
}

void test3() {
  int local = 1;
  const int *borrow p1 = &const local;
  // error: 指向local的可变和不可变借用不能同时存在
  int *borrow p2 = &mut local;
  read(p1);
  write(p2);
}

int main() {
  test1();
  test2();
  test3();
  return 0;
}
```

如果同时存在对一个变量的可变借用和不可变借用，可能会出现通过可变借用修改被借用对象的内存状态，然后再使用不可借用访问被修改的内存，从而导致未定义行为的情况。 例如：

```
#include <stdio.h>

struct A {
  int *p;
};

const int *borrow struct A::get_p(This *borrow this) {
  return &const * (this->p);
}

void struct A::free_p(This *borrow this) { free(this->p); }

int main() {
  struct A a = {.p = malloc(sizeof(int))};
  // q借用了a.p
  const int *borrow q = a.get_p();
  // a.p指向的内存被释放
  a.free_p();
  // *q的操作可能会导致未定义行为
  printf("%d\n", *q);
  return 0;
}
```

上述代码中，`a.free_p()`实际上使用了一个指向 a 的可变借用，该可变借用会使在它之前被定义的借用 q 失效，由于`printf("%d\n", *q)`使用了失效的 q，毕昇 C 编译器会报错，也就阻止了不安全行为的发生。

由于不可变借用不会导致被借用对象被修改，因此同一时刻可以拥有任意多个不可变借用，例如：

```
void read(const int *borrow p) {}

void test() {
  int local = 5;
  const int *borrow p1 = &const local;
  const int *borrow p2 = &const local;
  read(p1);
  read(p2);
}

int main() {
  test();
  return 0;
}
```

#### 4.借用对被借用对象的影响

##### 4.1 不可变借用对被借用对象的影响

对表达式 e 做不可变借用， 即`&const e`，在这个不可变借用的生命周期结束之前，e 只能读不能修改，也不能对 e 创建可变借用。

| 不可变借用表达式          | 被借用对象的状态                                             |
| ------------------------- | ------------------------------------------------------------ |
| &const ident`             | 变量 ident 只能被读不能被修改，也不能再对变量 ident 创建可变借用，允许对变量ident创建不可变借用 |
| &const "string literal"   | 临时变量永远是 “只读” 状态                                   |
| &const (struct S) { ... } | 临时变量永远是 “只读” 状态                                   |
| &const e->field           | e->field 进入 “只读” 状态，也不允许整体修改 *e。但允许修改 e 指向的其它成员，或者对其它成员做可变借用 |
| &const e.field            | e.field 进入 “只读” 状态，也不允许整体修改 e。但允许修改 e 的其它成员，或者对其它成员做可变借用 |
| &const e[index]           | e 进入 “只读” 状态，不允许修改 e 及其直接或间接成员，或者对其它成员做可变借用 |
| &const *e                 | *e 进入 “只读” 状态，不允许修改 *e 及其直接或间接成员，或者对其它成员做可变借用，如果 e 是 owned 指针类型，则 e 也进入只读状态 |

##### 4.2 可变借用对被借用对象的影响

对表达式 e 做可变借用， 即`&mut e`，表达式 e 进入 “冻结” 状态。在这个可变借用的生命周期结束之前，e 不能读，不能修改（包含被move），也不能被借用。

| 可变借用表达式          | 被借用对象的状态                                             |
| ----------------------- | ------------------------------------------------------------ |
| &mut ident`             | 变量 ident 被冻结                                            |
| &mut "string literal"   | 编译错误                                                     |
| &mut (struct S) { ... } | 临时变量被冻结                                               |
| &mut e->field           | e->field 被冻结，不允许读写 e->field，不允许整体修改 *e，但允许修改 e 指向的其它成员，或者对其它成员做可变借用 |
| &mut e.field            | e.field 被冻结，不允许读写 e.field，不允许整体修改 e，但允许修改 e 的其它成员，或者对其它成员做可变借用 |
| &mut e[index]           | e 被冻结，不允许读写 e 以及它的成员                          |
| &mut *e                 | *e 被冻结，不允许读写 *e 以及它的成员，如果 e 是 owned 指针类型，则也不允许读写 e |

#### 5. 函数定义中包含借用类型

1. 不允许函数参数中没有借用类型的参数，但是函数返回是借用类型。
2. 如果函数参数中有一个借用类型的参数，函数返回是借用类型，那么我们直接认为这个返回值的借用，是来自于这个借用类型参数，返回的借用的 “被借用对象” 与这个借用类型参数的 “被借用对象” 一样，这个返回的借用也应该满足前面提到的那些借用规则。
3. 如果函数参数中有多个借用类型的参数，函数返回是借用类型，那么我们直接认为这个返回值的借用，同时包含了从多个借用类型参数传递过来的 “被借用变量”，这个返回的借用也应该满足前面提到的那些借用规则。

```
int *borrow f1(int *borrow p) { return p; }
int *borrow f2(int *borrow p1, int *borrow p2) { return p1; }

void test() {
  int local = 5;
  int *borrow p1 = f1(&mut local);
  /* 函数 f1 的参数创建了一个对 local 的可变借用，这个借用被传递给了返回值 p1，
     导致 p1 相当于是对 local 的一个可变借用, 所以返回值 p1 的被借用对象是
     local, 在 p1 的生命周期结束之前，local 会一直被冻结。*/

  int local1, local2;
  int *borrow p2 = f2(&mut local1, &mut local2);
  /* 函数 f2 的参数创建了一个对 local1 和 local2
     的可变借用，这两个借用被传递给了返回值 p2， 导致 p2 相当于是对 local1 和
     local2 的一个可变借用, 所以返回值 p2 的被借用对象是 local1 和 local2, 在 p2
     的生命周期结束之前，local1 和 local2 一直被冻结。*/
}

int main() {
  test();
  return 0;
}
```

#### 6. struct定义中包含借用类型

1. 结构体的成员可以是借用类型，带有借用类型成员的结构体变量在定义的时候必须初始化。
2. 结构体内如果包含多个借用成员，那么这个结构体同时存在多个 “被借用对象”，这些借用成员也应该满足前面提到的那些借用规则。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct R {
  int *borrow m1;
  int *borrow m2;
};

void test() {
  int local1, local2;
  struct R r = {.m1 = &mut local1, .m2 = &mut local2};
  // 在 r 的生命周期结束之前，local1 和 local2 一直被冻结。
  // 因为变量 r 在初始化的时候创建了一个对 local1 和 local2 的可变借用，
  // 导致 r 同时包含对 local1 的一个可变借用，也包含对 local2 的可变借用。
}

int main() {
  test();
  return 0;
}
```

#### 7. 借用变量的解引用操作

允许对借用指针变量解引用，与标准 C 的解引用操作一致：对借用指针变量`p`解引用的语法为 `*p`。 对`const T * borrow`类型的借用变量`e`解引用 `*e`，结果为`T`类型 对`T * borrow`类型的借用变量`e`解引用 `*e`，结果为`T`类型 如果`p`是指向`T`类型的借用，`o`是`T`类型的 lvalue，对于`*p`表达式，有如下限制：

|              | T是Copy语义       | T是Move语义       |
| ------------ | ----------------- | ----------------- |
| p是immut借用 | *p = expr; 不允许 | *p = expr; 不允许 |
|              | o = *p; 允许      | o = *p; 不允许    |
| p是mut借用   | *p = expr; 允许   | *p = expr; 允许   |
|              | o = *p; 允许      | o = *p; 不允许    |

上表中 move / copy 语义分别指： `T`是`owned`修饰的类型和`T`是其它类型。

注：上表中的赋值操作的权限，可同样应用于函数的传参和返回场景。

#### 8. 借用变量的成员访问

允许借用指针变量访问成员变量或调用成员函数，与标准 C 的箭头运算符一致：访问指针变量`p`的成员变量`field`的语法为`p->field`，调用指针变量`p`的成员方法`method()`的语法为`p->method()`。

##### 8.1 访问成员变量

通过借用访问成员变量，表达式的类型取决于成员变量本身的类型。`p->field` 表达式的类型与`field`成员定义的类型相同。 如果 `p->field` 的类型是`T`，`o`是`T`类型的 lvalue，对于 `p->field` 表达式，有如下限制：

|              | T是Copy语义             | T是Move语义             |
| ------------ | ----------------------- | ----------------------- |
| p是immut借用 | p->field = expr; 不允许 | p->field = expr; 不允许 |
|              | o = p->field; 允许      | o = p->field; 不允许    |
| p是mut借用   | p->field = expr; 允许   | p->field = expr; 允许   |
|              | o = p->field; 允许      | o = p->field; 不允许    |

上表中 move / copy 语义分别指： T 是 owned 修饰的类型和 T 是其它类型。

注：上表中的赋值操作的权限，可同样应用于函数的传参和返回场景。

##### 8.2 调用成员函数

通过借用调用成员函数，即 `p->method()` 的场景，实参和形参之间的规则如下：

|              | void method(const This * borrow this) | void method(This * borrow this)    |      |
| ------------ | ------------------------------------- | ---------------------------------- | ---- |
| p是immut借用 | 允许                                  | 不允许，immut借用不能创建出mut借用 |      |
| p是mut借用   | 允许，允许从mut借用创建immut借用      | 允许                               |      |

举例来说：

```
void int ::method1(const This *borrow this) {}
void int ::method2(This *borrow this) {}

void test() {
  int local = 5;
  const int *borrow p1 = &const local;
  int *borrow p2 = &mut local;
  // ok: 形参类型和实参类型一致，都是不可变借用
  p1->method1();
  // error: 形参是可变借用类型，实参是不可变借用类型，不可变借用不能创建出可变借用
  p1->method2();
  // ok: 形参是不可变借用类型，实参是可变借用类型，允许从可变借用创建出不可变借用
  p2->method1();
  // ok: 形参类型和实参类型一致，都是可变借用
  p2->method2();
}

int main() {
  test();
  return 0;
}
```

#### 9. 借用的类型转换

1. 对于任意类型 T，如果 T 实现了 trait TR，则允许指向类型 T 的借用向上转型为指向类型 TR 的借用；反过来，从类型 TR 的借用往类型 T 借用的转换，是不允许的。

```
#include <stdio.h>

trait TR { void print(This * borrow this); };
void int ::print(int *this) { printf("%d\n", *this); }

impl trait TR for int;

void test() {
  int x = 10;
  int *borrow r = &mut x;
  // ok: 支持 int* 类型的借用向上转型为 trait TR* 类型的借用
  trait TR *borrow p = r;
  p->print();
  // error: 禁止 trait TR* 向下转型
  int *borrow px = (int *borrow)p;
}

int main() {
  test();
  return 0;
}
```

1. 允许指向类型 T 的借用转换为指向 void 类型的借用，反过来从类型 void 的借用往类型 T 借用的转换，是不允许的。

```
void test() {
  int x = 10;
  int *borrow r = &mut x;
  void *borrow p = r;
  // error: 不允许转为 void *borrow 类型
  int *borrow t = (int *borrow)p;
}

int main() {
  test();
  return 0;
}
```

1. 只允许在非安全区进行`T * borrow`和`T *`之间的转换。

```
int main() {
  // ok: 非安全区允许 T * borrow 和 T * 之间的转换
  int *borrow p = (int *borrow)NULL;
  // error: 安全区禁止 T * borrow 和 T * 之间的转换
  safe { int *borrow p = (int *borrow)NULL; }
  return 0;
}
```

#### 10. 借用的其它规则

除了上面的那些规则，对于借用，我们还有如下规则：

1. 对于全局变量，我们无法在函数签名中跟踪哪个函数读取了全局变量，哪个函数修改了全局变量。为了保证安全性，毕昇 C 规定：在安全区内，只允许对全局变量取只读借用，不允许取可变借用。如果是对函数名做借用，从生命周期的角度，可以当做是对全局变量做借用。
2. 借用变量在定义的时候必须初始化。

```
void test() {
  // error: 必须初始化
  int *borrow p;
}

int main() {
  test();
  return 0;
}
```

1. 用一个借用类型的表达式给另外一个借用类型的 lvalue作初始化或再赋值，即`p = e`，`p`和`e`必须是同类型的借用类型，而且要求`e`的生命周期必须大于 p 的生命周期。

```
#include <stdio.h>

void test() {
  int x = 1;
  int *borrow p = &mut x;
  {
    int y = 2;
    int *borrow pp = &mut y;
    // error: pp 生命周期小于 p
    p = pp;
    printf("%d\n", *p);
  }
  printf("%d\n", *p);
}

int main() {
  test();
  return 0;
}
```

基于此规则，一个`struct`内部的`borrow`指针成员，是不可以对这个`struct`或者它的其它成员做借用的。

```
struct S {
  int m;
  const int *borrow p;
};

void test() {
  // error: 因为s.p的生命周期与s.m的生命周期相同
  struct S s = {.m = 0, .p = &const s.m};
}

int main() {
  test();
  return 0;
}
```

1. 借用变量不允许是全局变量，只能是局部变量。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

int g = 5;
// error: 借用变量不允许是全局变量
int *borrow p = &mut g;
void test() { int *borrow p = &mut g; }

int main() {
  test();
  return 0;
}
```

1. 不允许对包含借用的表达式，再取借用。同理，借用类型`T* borrow`中，`T`本身及其成员不能是借用类型。

```
#include "bishengc_safety.hbs" // BiShengC 语言提供的头文件，用于安全地进行内存分配及释放

struct R {
  int *borrow p;
};

void test() {
  int local = 5;
  // error: 不允许多级借用指针
  int *borrow *borrow p = &mut(&mut local);

  struct R r1 = {.p = &mut local};
  // error: r1 中已经包含了借用
  struct R *borrow r2 = &mut r1;
}

int main() {
  test();
  return 0;
}
```

1. 不允许为借用类型实现 trait。

```
trait TR{};

// error: 不允许为借用类型实现 trait
impl trait TR for int *borrow;

int main() { return 0; }
```

1. 不允许为借用类型添加成员函数。

```
// error: 不允许为借用类型添加成员函数
void int *borrow::f() {} 

int main() { return 0; }
```

1. union 的成员不允许是借用类型。

```
// error: 借用指针不允许作为 union 成员
union U {
  int *borrow p;
};

int main() { return 0; }
```

1. 借用指针类型不能是泛型实参。
2. 借用指针变量不支持索引运算。
3. 借用指针变量不支持算术运算。
4. 允许同类型的借用变量之间，使用 `==`、`!=`、`>`、`<`、`<=`、`>=` 等比较运算符操作。
5. 允许对借用类型使用 `sizeof`、`alignof`操作符，并且有： `sizeof(T* borrow) == sizeof(T*)` `_Alignof(T* borrow) == _Alignof(T*)`
6. 允许对借用类型使用一元的`&`、`!`及二元的`&&`、`||`运算符。
7. 不允许对借用类型使用一元的`-`、`~`、`&const`、`&mut`、`[]`、`++`、`--`运算符，也不允许对借用类型使用二元的`*`、`/`、`%`、`&`、`|`、`<<`、`>>`、`+`、`-`运算符。
8. 如果一个借用指针变量指向的是函数，那么可以通过这个借用指针变量来调用函数。

```
#include <stdio.h>

void f() { printf("f()\n"); }

void test() {
  // ok: 对函数取不可变借用
  void (*borrow const p)() = &const f;
  p();
}

int main() {
  test();
  return 0;
}
```

1. 不允许对函数做可变借用，只能做只读借用。