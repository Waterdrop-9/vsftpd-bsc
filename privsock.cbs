/*
 * Part of Very Secure FTPd
 * Licence: GPL v2
 * Author: Chris Evans
 * privsock.c
 *
 * This file contains code for a simple message and file descriptor passing
 * API, over a pair of UNIX sockets.
 * The messages are typically travelling across a privilege boundary, with
 * heavy distrust of messages on the side of more privilege.
 */

#include "privsock.hbs"

#include "utility.hbs"
#include "defs.hbs"
#include "str.hbs"
#include "netstr.hbs"
#include "sysutil.hbs"
#include "sysdeputil.hbs"
#include "session.hbs"

unsafe void
priv_sock_init(struct vsf_session* p_sess)
{
  if (p_sess == 0)
  {
    return;
  }
  struct vsf_sysutil_socketpair_retval retval;
  if (p_sess->parent_fd != -1)
  {
    bug("parent_fd active");
  }
  if (p_sess->child_fd != -1)
  {
    bug("child_fd active");
  }
  retval = vsf_sysutil_unix_stream_socketpair();
  p_sess->parent_fd = retval.socket_one;
  p_sess->child_fd = retval.socket_two;
}

unsafe void
priv_sock_close(struct vsf_session* p_sess)
{
  if (p_sess == 0)
  {
    return;
  }
  if (p_sess->parent_fd != -1)
  {
    vsf_sysutil_close(p_sess->parent_fd);
    p_sess->parent_fd = -1;
  }
  if (p_sess->child_fd != -1)
  {
    vsf_sysutil_close(p_sess->child_fd);
    p_sess->child_fd = -1;
  }
}

unsafe void
priv_sock_set_parent_context(struct vsf_session* p_sess)
{
  if (p_sess == 0)
  {
    return;
  }
  if (p_sess->child_fd == -1)
  {
    bug("child_fd not active");
  }
  vsf_sysutil_close(p_sess->child_fd);
  p_sess->child_fd = -1;
}

unsafe void
priv_sock_set_child_context(struct vsf_session* p_sess)
{
  if (p_sess == 0)
  {
    return;
  }
  if (p_sess->parent_fd == -1)
  {
    bug("parent_fd not active");
  }
  vsf_sysutil_close(p_sess->parent_fd);
  p_sess->parent_fd = -1;
}

unsafe void
priv_sock_send_cmd(int fd, char cmd)
{
  if (fd < 0)
  {
    die("priv_sock_send_cmd invalid fd");
  }
  int retval = vsf_sysutil_write_loop(fd, &cmd, sizeof(cmd));
  if (retval != sizeof(cmd))
  {
    die("priv_sock_send_cmd");
  }
}

unsafe void
priv_sock_send_str(int fd, const struct mystr* borrow p_str)
{
  if (fd < 0 || p_str == 0)
  {
    die("priv_sock_send_str invalid args");
  }
  const struct mystr* p_raw_str = (const struct mystr*) p_str;
  unsigned int len = str_getlen(p_raw_str);
  priv_sock_send_int(fd, (int) len);
  if (len > 0)
  {
    str_netfd_write(p_raw_str, fd);
  }
}

unsafe void
priv_sock_send_buf(int fd, const char* borrow p_buf, unsigned int len)
{
  if (fd < 0 || (p_buf == 0 && len > 0))
  {
    die("priv_sock_send_buf invalid args");
  }
  priv_sock_send_int(fd, (int) len);
  if (len > 0)
  {
    if (vsf_sysutil_write_loop(fd, p_buf, len) != (int) len)
    {
      die("priv_sock_send_buf");
    }
  }
}

unsafe void
priv_sock_recv_buf(int fd, char* borrow p_buf, unsigned int len)
{
  if (fd < 0 || p_buf == 0)
  {
    die("priv_sock_recv_buf invalid args");
  }
  unsigned int recv_len = (unsigned int) priv_sock_get_int(fd);
  if (recv_len > len)
  {
    bug("recv_len bigger than buffer");
  }
  if (recv_len > 0)
  {
    if (vsf_sysutil_read_loop(fd, p_buf, recv_len) != (int) recv_len)
    {
      die("priv_sock_recv_buf");
    }
  }
}

unsafe char
priv_sock_get_result(int fd)
{
  if (fd < 0)
  {
    die("priv_sock_get_result invalid fd");
  }
  char res;
  int retval = vsf_sysutil_read_loop(fd, &res, sizeof(res));
  if (retval != sizeof(res))
  {
    die("priv_sock_get_result");
  }
  return res;
}

unsafe char
priv_sock_get_cmd(int fd)
{
  if (fd < 0)
  {
    die("priv_sock_get_cmd invalid fd");
  }
  char res;
  int retval = vsf_sysutil_read_loop(fd, &res, sizeof(res));
  if (retval != sizeof(res))
  {
    die("priv_sock_get_cmd");
  }
  return res;
}

unsafe void
priv_sock_get_str(int fd, struct mystr* borrow p_dest)
{
  if (fd < 0 || p_dest == 0)
  {
    die("priv_sock_get_str invalid args");
  }
  struct mystr* p_raw_dest = (struct mystr*) p_dest;
  unsigned int len = (unsigned int) priv_sock_get_int(fd);
  if (len > VSFTP_PRIVSOCK_MAXSTR)
  {
    die("priv_sock_get_str: too big");
  }
  str_empty(p_raw_dest);
  if (len > 0)
  {
    int retval = str_netfd_read(p_raw_dest, fd, len);
    if ((unsigned int) retval != len)
    {
      die("priv_sock_get_str: read error");
    }
  }
}

unsafe void
priv_sock_send_result(int fd, char res)
{
  if (fd < 0)
  {
    die("priv_sock_send_result invalid fd");
  }
  int retval = vsf_sysutil_write_loop(fd, &res, sizeof(res));
  if (retval != sizeof(res))
  {
    die("priv_sock_send_result");
  }
}

unsafe void
priv_sock_send_fd(int fd, int send_fd)
{
  if (fd < 0 || send_fd < 0)
  {
    die("priv_sock_send_fd invalid fd");
  }
  vsf_sysutil_send_fd(fd, send_fd);
}

unsafe int
priv_sock_recv_fd(int fd)
{
  if (fd < 0)
  {
    return -1;
  }
  return vsf_sysutil_recv_fd(fd);
}

unsafe void
priv_sock_send_int(int fd, int the_int)
{
  if (fd < 0)
  {
    die("priv_sock_send_int invalid fd");
  }
  int retval = vsf_sysutil_write_loop(fd, &the_int, sizeof(the_int));
  if (retval != sizeof(the_int))
  {
    die("priv_sock_send_int");
  }
}

unsafe int
priv_sock_get_int(int fd)
{
  if (fd < 0)
  {
    die("priv_sock_get_int invalid fd");
  }
  int the_int;
  int retval = vsf_sysutil_read_loop(fd, &the_int, sizeof(the_int));
  if (retval != sizeof(the_int))
  {
    die("priv_sock_get_int");
  }
  return the_int;
}
